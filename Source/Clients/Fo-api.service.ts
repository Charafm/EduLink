//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IReferentialClient {
    getAllRegions(): Promise<RegionDTO[]>;
    getRegionById(regionId: string): Promise<RegionDTO>;
    searchRegions(fragment: string): Promise<RegionDTO[]>;
    getAllCities(): Promise<CityDTO[]>;
    getCityById(cityId: string): Promise<CityDTO>;
    getCitiesByRegion(regionId: string): Promise<CityDTO[]>;
    searchCities(fragment: string): Promise<CityDTO[]>;
    getAllSchools(): Promise<SchoolMetadataDTO[]>;
    getSchoolById(schoolId: string): Promise<SchoolMetadataDTO>;
    getSchoolsByCity(cityId: string): Promise<SchoolMetadataDTO[]>;
    getSchoolsByRegion(regionId: string): Promise<SchoolMetadataDTO[]>;
    searchSchools(fragment: string): Promise<SchoolMetadataDTO[]>;
}

export class ReferentialClient implements IReferentialClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getAllRegions( cancelToken?: CancelToken): Promise<RegionDTO[]> {
        let url_ = this.baseUrl + "/referential/getallregions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRegions(_response);
        });
    }

    protected processGetAllRegions(response: AxiosResponse): Promise<RegionDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RegionDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionDTO[]>(null as any);
    }

    getRegionById(regionId: string, cancelToken?: CancelToken): Promise<RegionDTO> {
        let url_ = this.baseUrl + "/referential/getregionbyid/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRegionById(_response);
        });
    }

    protected processGetRegionById(response: AxiosResponse): Promise<RegionDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegionDTO.fromJS(resultData200);
            return Promise.resolve<RegionDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionDTO>(null as any);
    }

    searchRegions(fragment: string, cancelToken?: CancelToken): Promise<RegionDTO[]> {
        let url_ = this.baseUrl + "/referential/searchregions/{fragment}";
        if (fragment === undefined || fragment === null)
            throw new Error("The parameter 'fragment' must be defined.");
        url_ = url_.replace("{fragment}", encodeURIComponent("" + fragment));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchRegions(_response);
        });
    }

    protected processSearchRegions(response: AxiosResponse): Promise<RegionDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RegionDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionDTO[]>(null as any);
    }

    getAllCities( cancelToken?: CancelToken): Promise<CityDTO[]> {
        let url_ = this.baseUrl + "/referential/getallcities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllCities(_response);
        });
    }

    protected processGetAllCities(response: AxiosResponse): Promise<CityDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CityDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO[]>(null as any);
    }

    getCityById(cityId: string, cancelToken?: CancelToken): Promise<CityDTO> {
        let url_ = this.baseUrl + "/referential/getcitybyid/{cityId}";
        if (cityId === undefined || cityId === null)
            throw new Error("The parameter 'cityId' must be defined.");
        url_ = url_.replace("{cityId}", encodeURIComponent("" + cityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCityById(_response);
        });
    }

    protected processGetCityById(response: AxiosResponse): Promise<CityDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CityDTO.fromJS(resultData200);
            return Promise.resolve<CityDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO>(null as any);
    }

    getCitiesByRegion(regionId: string, cancelToken?: CancelToken): Promise<CityDTO[]> {
        let url_ = this.baseUrl + "/referential/getcitiesbyregion/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCitiesByRegion(_response);
        });
    }

    protected processGetCitiesByRegion(response: AxiosResponse): Promise<CityDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CityDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO[]>(null as any);
    }

    searchCities(fragment: string, cancelToken?: CancelToken): Promise<CityDTO[]> {
        let url_ = this.baseUrl + "/referential/searchcities/{fragment}";
        if (fragment === undefined || fragment === null)
            throw new Error("The parameter 'fragment' must be defined.");
        url_ = url_.replace("{fragment}", encodeURIComponent("" + fragment));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchCities(_response);
        });
    }

    protected processSearchCities(response: AxiosResponse): Promise<CityDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CityDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO[]>(null as any);
    }

    getAllSchools( cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referential/getallschools";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSchools(_response);
        });
    }

    protected processGetAllSchools(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }

    getSchoolById(schoolId: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO> {
        let url_ = this.baseUrl + "/referential/getschoolbyid/{schoolId}";
        if (schoolId === undefined || schoolId === null)
            throw new Error("The parameter 'schoolId' must be defined.");
        url_ = url_.replace("{schoolId}", encodeURIComponent("" + schoolId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchoolById(_response);
        });
    }

    protected processGetSchoolById(response: AxiosResponse): Promise<SchoolMetadataDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SchoolMetadataDTO.fromJS(resultData200);
            return Promise.resolve<SchoolMetadataDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO>(null as any);
    }

    getSchoolsByCity(cityId: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referential/getschoolsbycity/{cityId}";
        if (cityId === undefined || cityId === null)
            throw new Error("The parameter 'cityId' must be defined.");
        url_ = url_.replace("{cityId}", encodeURIComponent("" + cityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchoolsByCity(_response);
        });
    }

    protected processGetSchoolsByCity(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }

    getSchoolsByRegion(regionId: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referential/getschoolsbyregion/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchoolsByRegion(_response);
        });
    }

    protected processGetSchoolsByRegion(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }

    searchSchools(fragment: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referential/searchschools/{fragment}";
        if (fragment === undefined || fragment === null)
            throw new Error("The parameter 'fragment' must be defined.");
        url_ = url_.replace("{fragment}", encodeURIComponent("" + fragment));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchSchools(_response);
        });
    }

    protected processSearchSchools(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }
}

export interface IAcademicsClient {
    getGraderResources(filter: ResourceFilterDTO): Promise<PagedResultOfGradeResourceDTO>;
    getCurrentYear(): Promise<AcademicYearDTO>;
}

export class AcademicsClient implements IAcademicsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getGraderResources(filter: ResourceFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfGradeResourceDTO> {
        let url_ = this.baseUrl + "/academics/getgraderresources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGraderResources(_response);
        });
    }

    protected processGetGraderResources(response: AxiosResponse): Promise<PagedResultOfGradeResourceDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeResourceDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeResourceDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeResourceDTO>(null as any);
    }

    getCurrentYear( cancelToken?: CancelToken): Promise<AcademicYearDTO> {
        let url_ = this.baseUrl + "/academics/getcurrentyear";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentYear(_response);
        });
    }

    protected processGetCurrentYear(response: AxiosResponse): Promise<AcademicYearDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AcademicYearDTO.fromJS(resultData200);
            return Promise.resolve<AcademicYearDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AcademicYearDTO>(null as any);
    }
}

export interface IAttendanceClient {
    submitAttendanceExcuse(studentId: string | undefined, data: AttendanceExcuseDTO): Promise<boolean>;
    getAttendanceSummary(studentId: string | undefined, range: DateRangeDTO): Promise<AttendanceSummaryDTO>;
    getAttendanceRecords(studentId: string | undefined): Promise<AttendanceDTO[]>;
}

export class AttendanceClient implements IAttendanceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    submitAttendanceExcuse(studentId: string | undefined, data: AttendanceExcuseDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/attendance/submitattendanceexcuse?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitAttendanceExcuse(_response);
        });
    }

    protected processSubmitAttendanceExcuse(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAttendanceSummary(studentId: string | undefined, range: DateRangeDTO, cancelToken?: CancelToken): Promise<AttendanceSummaryDTO> {
        let url_ = this.baseUrl + "/attendance/getattendancesummary?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(range);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAttendanceSummary(_response);
        });
    }

    protected processGetAttendanceSummary(response: AxiosResponse): Promise<AttendanceSummaryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttendanceSummaryDTO.fromJS(resultData200);
            return Promise.resolve<AttendanceSummaryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttendanceSummaryDTO>(null as any);
    }

    getAttendanceRecords(studentId: string | undefined, cancelToken?: CancelToken): Promise<AttendanceDTO[]> {
        let url_ = this.baseUrl + "/attendance/getattendancerecords?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAttendanceRecords(_response);
        });
    }

    protected processGetAttendanceRecords(response: AxiosResponse): Promise<AttendanceDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttendanceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttendanceDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttendanceDTO[]>(null as any);
    }
}

export interface ICourseClient {
    getCoursesByGradeLevel(gradeLevelId: string): Promise<CourseDTO[]>;
    getCourseDetails(courseId: string): Promise<CourseDetailDTO>;
}

export class CourseClient implements ICourseClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getCoursesByGradeLevel(gradeLevelId: string, cancelToken?: CancelToken): Promise<CourseDTO[]> {
        let url_ = this.baseUrl + "/course/getcoursesbygradelevel/{GradeLevelId}";
        if (gradeLevelId === undefined || gradeLevelId === null)
            throw new Error("The parameter 'gradeLevelId' must be defined.");
        url_ = url_.replace("{GradeLevelId}", encodeURIComponent("" + gradeLevelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCoursesByGradeLevel(_response);
        });
    }

    protected processGetCoursesByGradeLevel(response: AxiosResponse): Promise<CourseDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CourseDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseDTO[]>(null as any);
    }

    getCourseDetails(courseId: string, cancelToken?: CancelToken): Promise<CourseDetailDTO> {
        let url_ = this.baseUrl + "/course/getcoursedetails/{CourseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{CourseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCourseDetails(_response);
        });
    }

    protected processGetCourseDetails(response: AxiosResponse): Promise<CourseDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CourseDetailDTO.fromJS(resultData200);
            return Promise.resolve<CourseDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseDetailDTO>(null as any);
    }
}

export interface IEnrollmentClient {
    uploadEnrollmentDocument(data: EnrollmentDocumentUploadDTO): Promise<boolean>;
    submitEnrollment(data: EnrollmentDTO): Promise<boolean>;
    getEnrollmentTranscript(enrollmentId: string): Promise<EnrollmentTranscriptDTO>;
    getEnrollment(enrollmentId: string): Promise<EnrollmentDetailDTO>;
}

export class EnrollmentClient implements IEnrollmentClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    uploadEnrollmentDocument(data: EnrollmentDocumentUploadDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/uploadenrollmentdocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadEnrollmentDocument(_response);
        });
    }

    protected processUploadEnrollmentDocument(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    submitEnrollment(data: EnrollmentDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/submitenrollment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitEnrollment(_response);
        });
    }

    protected processSubmitEnrollment(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getEnrollmentTranscript(enrollmentId: string, cancelToken?: CancelToken): Promise<EnrollmentTranscriptDTO> {
        let url_ = this.baseUrl + "/enrollment/getenrollmenttranscript/{EnrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{EnrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnrollmentTranscript(_response);
        });
    }

    protected processGetEnrollmentTranscript(response: AxiosResponse): Promise<EnrollmentTranscriptDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnrollmentTranscriptDTO.fromJS(resultData200);
            return Promise.resolve<EnrollmentTranscriptDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EnrollmentTranscriptDTO>(null as any);
    }

    getEnrollment(enrollmentId: string, cancelToken?: CancelToken): Promise<EnrollmentDetailDTO> {
        let url_ = this.baseUrl + "/enrollment/getenrollment/{EnrollmentId}";
        if (enrollmentId === undefined || enrollmentId === null)
            throw new Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{EnrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnrollment(_response);
        });
    }

    protected processGetEnrollment(response: AxiosResponse): Promise<EnrollmentDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnrollmentDetailDTO.fromJS(resultData200);
            return Promise.resolve<EnrollmentDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EnrollmentDetailDTO>(null as any);
    }
}

export interface IGradeClient {
    getGradeStatistics(filter: GradeFilterDTO): Promise<GradeStatisticsDTO>;
    getGrade(filter: GradeFilterDTO): Promise<PagedResultOfGradeDTO>;
    getGradeHistory(filter: GradeHistoryFilterDTO): Promise<PagedResultOfGradeHistoryDTO>;
    getStudentGPA(studentId: string): Promise<GpaDTO>;
}

export class GradeClient implements IGradeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getGradeStatistics(filter: GradeFilterDTO, cancelToken?: CancelToken): Promise<GradeStatisticsDTO> {
        let url_ = this.baseUrl + "/grade/getgradestatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGradeStatistics(_response);
        });
    }

    protected processGetGradeStatistics(response: AxiosResponse): Promise<GradeStatisticsDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GradeStatisticsDTO.fromJS(resultData200);
            return Promise.resolve<GradeStatisticsDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GradeStatisticsDTO>(null as any);
    }

    getGrade(filter: GradeFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfGradeDTO> {
        let url_ = this.baseUrl + "/grade/getgrade";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGrade(_response);
        });
    }

    protected processGetGrade(response: AxiosResponse): Promise<PagedResultOfGradeDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeDTO>(null as any);
    }

    getGradeHistory(filter: GradeHistoryFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfGradeHistoryDTO> {
        let url_ = this.baseUrl + "/grade/getgradehistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGradeHistory(_response);
        });
    }

    protected processGetGradeHistory(response: AxiosResponse): Promise<PagedResultOfGradeHistoryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeHistoryDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeHistoryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeHistoryDTO>(null as any);
    }

    getStudentGPA(studentId: string, cancelToken?: CancelToken): Promise<GpaDTO> {
        let url_ = this.baseUrl + "/grade/getstudentgpa/{StudentId}";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{StudentId}", encodeURIComponent("" + studentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudentGPA(_response);
        });
    }

    protected processGetStudentGPA(response: AxiosResponse): Promise<GpaDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GpaDTO.fromJS(resultData200);
            return Promise.resolve<GpaDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GpaDTO>(null as any);
    }
}

export interface ITransferClient {
    submitTransferRequest(data: TransferRequestDTO): Promise<boolean>;
    getTransferHistory(filterDTO: TransferHistoryFilterDTO): Promise<PagedResultOfTransferRequestHistoryDTO>;
    getTransferDetails(requestId: string | undefined): Promise<TransferRequestDetailDTO>;
    checkTransferEligibility(studentId: string | undefined): Promise<TransferEligibilityResultDTO>;
    cancelTransferRequest(requestId: string | undefined): Promise<boolean>;
}

export class TransferClient implements ITransferClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    submitTransferRequest(data: TransferRequestDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/transfer/submittransferrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitTransferRequest(_response);
        });
    }

    protected processSubmitTransferRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getTransferHistory(filterDTO: TransferHistoryFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfTransferRequestHistoryDTO> {
        let url_ = this.baseUrl + "/transfer/gettransferhistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterDTO);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTransferHistory(_response);
        });
    }

    protected processGetTransferHistory(response: AxiosResponse): Promise<PagedResultOfTransferRequestHistoryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfTransferRequestHistoryDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfTransferRequestHistoryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfTransferRequestHistoryDTO>(null as any);
    }

    getTransferDetails(requestId: string | undefined, cancelToken?: CancelToken): Promise<TransferRequestDetailDTO> {
        let url_ = this.baseUrl + "/transfer/gettransferdetails?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTransferDetails(_response);
        });
    }

    protected processGetTransferDetails(response: AxiosResponse): Promise<TransferRequestDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransferRequestDetailDTO.fromJS(resultData200);
            return Promise.resolve<TransferRequestDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferRequestDetailDTO>(null as any);
    }

    checkTransferEligibility(studentId: string | undefined, cancelToken?: CancelToken): Promise<TransferEligibilityResultDTO> {
        let url_ = this.baseUrl + "/transfer/checktransfereligibility?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckTransferEligibility(_response);
        });
    }

    protected processCheckTransferEligibility(response: AxiosResponse): Promise<TransferEligibilityResultDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransferEligibilityResultDTO.fromJS(resultData200);
            return Promise.resolve<TransferEligibilityResultDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferEligibilityResultDTO>(null as any);
    }

    cancelTransferRequest(requestId: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/transfer/canceltransferrequest?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            url_ += "RequestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelTransferRequest(_response);
        });
    }

    protected processCancelTransferRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IAppLifetimeClient {
    reload(): Promise<FileResponse>;
}

export class AppLifetimeClient implements IAppLifetimeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    reload( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/reload";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReload(_response);
        });
    }

    protected processReload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IResourcesClient {
    get(): Promise<{ [key: string]: { [key: string]: string; }; }>;
}

export class ResourcesClient implements IResourcesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get( cancelToken?: CancelToken): Promise<{ [key: string]: { [key: string]: string; }; }> {
        let url_ = this.baseUrl + "/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<{ [key: string]: { [key: string]: string; }; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : {};
                }
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<{ [key: string]: { [key: string]: string; }; }>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: { [key: string]: string; }; }>(null as any);
    }
}

export class RegionDTO implements IRegionDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;

    constructor(data?: IRegionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameFr = _data["nameFr"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
        }
    }

    static fromJS(data: any): RegionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameFr"] = this.nameFr;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        return data;
    }
}

export interface IRegionDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
}

export class CityDTO implements ICityDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    regionId?: string;

    constructor(data?: ICityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameFr = _data["nameFr"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.regionId = _data["regionId"];
        }
    }

    static fromJS(data: any): CityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameFr"] = this.nameFr;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["regionId"] = this.regionId;
        return data;
    }
}

export interface ICityDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    regionId?: string;
}

export class SchoolMetadataDTO implements ISchoolMetadataDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    code?: string;
    addressFr?: string;
    addressAr?: string;
    addressEn?: string;
    regionId?: string;
    regionNameFr?: string;
    regionNameAr?: string;
    regionNameEn?: string;
    cityId?: string;
    cityNameFr?: string;
    cityNameAr?: string;
    cityNameEn?: string;
    useIsolatedDatabase?: boolean;
    hasCustomConnectionString?: boolean;
    logoUrl?: string;
    timeZoneId?: string;

    constructor(data?: ISchoolMetadataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameFr = _data["nameFr"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.code = _data["code"];
            this.addressFr = _data["addressFr"];
            this.addressAr = _data["addressAr"];
            this.addressEn = _data["addressEn"];
            this.regionId = _data["regionId"];
            this.regionNameFr = _data["regionNameFr"];
            this.regionNameAr = _data["regionNameAr"];
            this.regionNameEn = _data["regionNameEn"];
            this.cityId = _data["cityId"];
            this.cityNameFr = _data["cityNameFr"];
            this.cityNameAr = _data["cityNameAr"];
            this.cityNameEn = _data["cityNameEn"];
            this.useIsolatedDatabase = _data["useIsolatedDatabase"];
            this.hasCustomConnectionString = _data["hasCustomConnectionString"];
            this.logoUrl = _data["logoUrl"];
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): SchoolMetadataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolMetadataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameFr"] = this.nameFr;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["code"] = this.code;
        data["addressFr"] = this.addressFr;
        data["addressAr"] = this.addressAr;
        data["addressEn"] = this.addressEn;
        data["regionId"] = this.regionId;
        data["regionNameFr"] = this.regionNameFr;
        data["regionNameAr"] = this.regionNameAr;
        data["regionNameEn"] = this.regionNameEn;
        data["cityId"] = this.cityId;
        data["cityNameFr"] = this.cityNameFr;
        data["cityNameAr"] = this.cityNameAr;
        data["cityNameEn"] = this.cityNameEn;
        data["useIsolatedDatabase"] = this.useIsolatedDatabase;
        data["hasCustomConnectionString"] = this.hasCustomConnectionString;
        data["logoUrl"] = this.logoUrl;
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface ISchoolMetadataDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    code?: string;
    addressFr?: string;
    addressAr?: string;
    addressEn?: string;
    regionId?: string;
    regionNameFr?: string;
    regionNameAr?: string;
    regionNameEn?: string;
    cityId?: string;
    cityNameFr?: string;
    cityNameAr?: string;
    cityNameEn?: string;
    useIsolatedDatabase?: boolean;
    hasCustomConnectionString?: boolean;
    logoUrl?: string;
    timeZoneId?: string;
}

export abstract class PagedResultBase implements IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;

    constructor(data?: IPagedResultBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
        }
    }

    static fromJS(data: any): PagedResultBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PagedResultBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        return data;
    }
}

export interface IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
}

export class PagedResultOfGradeResourceDTO extends PagedResultBase implements IPagedResultOfGradeResourceDTO {
    results?: GradeResourceDTO[];

    constructor(data?: IPagedResultOfGradeResourceDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GradeResourceDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfGradeResourceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfGradeResourceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfGradeResourceDTO extends IPagedResultBase {
    results?: GradeResourceDTO[];
}

export class GradeResourceDTO implements IGradeResourceDTO {
    id?: string;
    gradeLevelId?: string;
    bookId?: string | undefined;
    schoolSupplyId?: string | undefined;
    supplyQuantity?: number | undefined;
    gradeLevelName?: string;
    resourceTitle?: string;

    constructor(data?: IGradeResourceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gradeLevelId = _data["gradeLevelId"];
            this.bookId = _data["bookId"];
            this.schoolSupplyId = _data["schoolSupplyId"];
            this.supplyQuantity = _data["supplyQuantity"];
            this.gradeLevelName = _data["gradeLevelName"];
            this.resourceTitle = _data["resourceTitle"];
        }
    }

    static fromJS(data: any): GradeResourceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeResourceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gradeLevelId"] = this.gradeLevelId;
        data["bookId"] = this.bookId;
        data["schoolSupplyId"] = this.schoolSupplyId;
        data["supplyQuantity"] = this.supplyQuantity;
        data["gradeLevelName"] = this.gradeLevelName;
        data["resourceTitle"] = this.resourceTitle;
        return data;
    }
}

export interface IGradeResourceDTO {
    id?: string;
    gradeLevelId?: string;
    bookId?: string | undefined;
    schoolSupplyId?: string | undefined;
    supplyQuantity?: number | undefined;
    gradeLevelName?: string;
    resourceTitle?: string;
}

export class ResourceFilterDTO implements IResourceFilterDTO {
    gradeLevelId?: string | undefined;
    resourceType?: ResourceType | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IResourceFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeLevelId = _data["gradeLevelId"];
            this.resourceType = _data["resourceType"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResourceFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeLevelId"] = this.gradeLevelId;
        data["resourceType"] = this.resourceType;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResourceFilterDTO {
    gradeLevelId?: string | undefined;
    resourceType?: ResourceType | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export enum ResourceType {
    Book = "Book",
    SchoolSupply = "SchoolSupply",
}

export class AcademicYearDTO implements IAcademicYearDTO {
    startYear?: number;
    endYear?: number;
    description?: string;

    constructor(data?: IAcademicYearDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AcademicYearDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicYearDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["description"] = this.description;
        return data;
    }
}

export interface IAcademicYearDTO {
    startYear?: number;
    endYear?: number;
    description?: string;
}

export class AttendanceExcuseDTO implements IAttendanceExcuseDTO {
    attendanceId?: string;
    explanation?: string;
    language?: string;
    documentUrl?: string | undefined;
    submittedBy?: string;

    constructor(data?: IAttendanceExcuseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attendanceId = _data["attendanceId"];
            this.explanation = _data["explanation"];
            this.language = _data["language"];
            this.documentUrl = _data["documentUrl"];
            this.submittedBy = _data["submittedBy"];
        }
    }

    static fromJS(data: any): AttendanceExcuseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceExcuseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attendanceId"] = this.attendanceId;
        data["explanation"] = this.explanation;
        data["language"] = this.language;
        data["documentUrl"] = this.documentUrl;
        data["submittedBy"] = this.submittedBy;
        return data;
    }
}

export interface IAttendanceExcuseDTO {
    attendanceId?: string;
    explanation?: string;
    language?: string;
    documentUrl?: string | undefined;
    submittedBy?: string;
}

export class AttendanceSummaryDTO implements IAttendanceSummaryDTO {
    totalDays?: number;
    presentDays?: number;
    lateDays?: number;
    absentDays?: number;
    attendanceRate?: number;

    constructor(data?: IAttendanceSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalDays = _data["totalDays"];
            this.presentDays = _data["presentDays"];
            this.lateDays = _data["lateDays"];
            this.absentDays = _data["absentDays"];
            this.attendanceRate = _data["attendanceRate"];
        }
    }

    static fromJS(data: any): AttendanceSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalDays"] = this.totalDays;
        data["presentDays"] = this.presentDays;
        data["lateDays"] = this.lateDays;
        data["absentDays"] = this.absentDays;
        data["attendanceRate"] = this.attendanceRate;
        return data;
    }
}

export interface IAttendanceSummaryDTO {
    totalDays?: number;
    presentDays?: number;
    lateDays?: number;
    absentDays?: number;
    attendanceRate?: number;
}

export class DateRangeDTO implements IDateRangeDTO {
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IDateRangeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDateRangeDTO {
    startDate?: Date;
    endDate?: Date;
}

export class AttendanceDTO implements IAttendanceDTO {
    studentId?: string;
    courseId?: string;
    date?: Date;
    status?: AttendanceEnum;
    notesFr?: string | undefined;
    notesAr?: string | undefined;
    notesEn?: string | undefined;

    constructor(data?: IAttendanceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.courseId = _data["courseId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.notesFr = _data["notesFr"];
            this.notesAr = _data["notesAr"];
            this.notesEn = _data["notesEn"];
        }
    }

    static fromJS(data: any): AttendanceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["courseId"] = this.courseId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["notesFr"] = this.notesFr;
        data["notesAr"] = this.notesAr;
        data["notesEn"] = this.notesEn;
        return data;
    }
}

export interface IAttendanceDTO {
    studentId?: string;
    courseId?: string;
    date?: Date;
    status?: AttendanceEnum;
    notesFr?: string | undefined;
    notesAr?: string | undefined;
    notesEn?: string | undefined;
}

export enum AttendanceEnum {
    Present = "Present",
    Late = "Late",
    Absent = "Absent",
}

export class CourseDTO implements ICourseDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleFr = _data["titleFr"];
            this.titleAr = _data["titleAr"];
            this.titleEn = _data["titleEn"];
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleFr"] = this.titleFr;
        data["titleAr"] = this.titleAr;
        data["titleEn"] = this.titleEn;
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface ICourseDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;
}

export class CourseDetailDTO implements ICourseDetailDTO {
    titleFr?: string;
    titleAr?: string;
    titleEn?: string;
    code?: string;
    description?: string;
    teacherAssignments?: TeacherAssignmentDetailDTO[];
    gradeMappings?: CourseGradeMappingDTO[];
    materials?: CourseMaterialDTO[] | undefined;

    constructor(data?: ICourseDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleFr = _data["titleFr"];
            this.titleAr = _data["titleAr"];
            this.titleEn = _data["titleEn"];
            this.code = _data["code"];
            this.description = _data["description"];
            if (Array.isArray(_data["teacherAssignments"])) {
                this.teacherAssignments = [] as any;
                for (let item of _data["teacherAssignments"])
                    this.teacherAssignments!.push(TeacherAssignmentDetailDTO.fromJS(item));
            }
            if (Array.isArray(_data["gradeMappings"])) {
                this.gradeMappings = [] as any;
                for (let item of _data["gradeMappings"])
                    this.gradeMappings!.push(CourseGradeMappingDTO.fromJS(item));
            }
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(CourseMaterialDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleFr"] = this.titleFr;
        data["titleAr"] = this.titleAr;
        data["titleEn"] = this.titleEn;
        data["code"] = this.code;
        data["description"] = this.description;
        if (Array.isArray(this.teacherAssignments)) {
            data["teacherAssignments"] = [];
            for (let item of this.teacherAssignments)
                data["teacherAssignments"].push(item.toJSON());
        }
        if (Array.isArray(this.gradeMappings)) {
            data["gradeMappings"] = [];
            for (let item of this.gradeMappings)
                data["gradeMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseDetailDTO {
    titleFr?: string;
    titleAr?: string;
    titleEn?: string;
    code?: string;
    description?: string;
    teacherAssignments?: TeacherAssignmentDetailDTO[];
    gradeMappings?: CourseGradeMappingDTO[];
    materials?: CourseMaterialDTO[] | undefined;
}

export class TeacherAssignmentDetailDTO implements ITeacherAssignmentDetailDTO {
    teacherId?: string;
    teacherName?: string;
    academicYearId?: string;

    constructor(data?: ITeacherAssignmentDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.teacherName = _data["teacherName"];
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): TeacherAssignmentDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAssignmentDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["teacherName"] = this.teacherName;
        data["academicYearId"] = this.academicYearId;
        return data;
    }
}

export interface ITeacherAssignmentDetailDTO {
    teacherId?: string;
    teacherName?: string;
    academicYearId?: string;
}

export class CourseGradeMappingDTO implements ICourseGradeMappingDTO {
    courseId?: string;
    gradeLevelId?: string;
    isElective?: boolean | undefined;

    constructor(data?: ICourseGradeMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.gradeLevelId = _data["gradeLevelId"];
            this.isElective = _data["isElective"];
        }
    }

    static fromJS(data: any): CourseGradeMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseGradeMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["gradeLevelId"] = this.gradeLevelId;
        data["isElective"] = this.isElective;
        return data;
    }
}

export interface ICourseGradeMappingDTO {
    courseId?: string;
    gradeLevelId?: string;
    isElective?: boolean | undefined;
}

export class CourseMaterialDTO implements ICourseMaterialDTO {
    id?: string;
    title?: string;
    content?: string;
    lastModified?: Date;

    constructor(data?: ICourseMaterialDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseMaterialDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseMaterialDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICourseMaterialDTO {
    id?: string;
    title?: string;
    content?: string;
    lastModified?: Date;
}

export class EnrollmentDocumentUploadDTO implements IEnrollmentDocumentUploadDTO {
    enrollmentId?: string;
    documentType?: DocumentTypeEnum;
    fileName?: string;
    contentType?: string;
    fileContent?: string;

    constructor(data?: IEnrollmentDocumentUploadDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.documentType = _data["documentType"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.fileContent = _data["fileContent"];
        }
    }

    static fromJS(data: any): EnrollmentDocumentUploadDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentDocumentUploadDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["documentType"] = this.documentType;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["fileContent"] = this.fileContent;
        return data;
    }
}

export interface IEnrollmentDocumentUploadDTO {
    enrollmentId?: string;
    documentType?: DocumentTypeEnum;
    fileName?: string;
    contentType?: string;
    fileContent?: string;
}

export enum DocumentTypeEnum {
    Unspecified = "Unspecified",
    UserAvatar = "UserAvatar",
    CNI = "CNI",
    CNIFront = "CNIFront",
    CNIBack = "CNIBack",
    CNIFatherFront = "CNIFatherFront",
    CNIFatherBack = "CNIFatherBack",
    CNIMotherFront = "CNIMotherFront",
    CNIMotherBack = "CNIMotherBack",
    ProofOfAddress = "ProofOfAddress",
    Extrait = "Extrait",
    Picture = "Picture",
}

export class EnrollmentDTO implements IEnrollmentDTO {
    studentId?: string;
    branchId?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    adminComment?: string | undefined;

    constructor(data?: IEnrollmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.branchId = _data["branchId"];
            this.status = _data["status"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            this.adminComment = _data["adminComment"];
        }
    }

    static fromJS(data: any): EnrollmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["branchId"] = this.branchId;
        data["status"] = this.status;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["adminComment"] = this.adminComment;
        return data;
    }
}

export interface IEnrollmentDTO {
    studentId?: string;
    branchId?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    adminComment?: string | undefined;
}

export enum EnrollmentStatusEnum {
    None = "None",
    Pending = "Pending",
    UnderReview = "UnderReview",
    Approved = "Approved",
    Rejected = "Rejected",
    Completed = "Completed",
}

export class EnrollmentTranscriptDTO implements IEnrollmentTranscriptDTO {
    enrollmentId?: string;
    studentId?: string;
    studentName?: string;
    branchName?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    statusHistory?: EnrollmentStatusHistoryDTO[];
    documents?: DocumentDTO[];

    constructor(data?: IEnrollmentTranscriptDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.branchName = _data["branchName"];
            this.status = _data["status"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["statusHistory"])) {
                this.statusHistory = [] as any;
                for (let item of _data["statusHistory"])
                    this.statusHistory!.push(EnrollmentStatusHistoryDTO.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnrollmentTranscriptDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentTranscriptDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["branchName"] = this.branchName;
        data["status"] = this.status;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.statusHistory)) {
            data["statusHistory"] = [];
            for (let item of this.statusHistory)
                data["statusHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEnrollmentTranscriptDTO {
    enrollmentId?: string;
    studentId?: string;
    studentName?: string;
    branchName?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    statusHistory?: EnrollmentStatusHistoryDTO[];
    documents?: DocumentDTO[];
}

export class EnrollmentStatusHistoryDTO implements IEnrollmentStatusHistoryDTO {
    enrollmentId?: string;
    oldStatus?: EnrollmentStatusEnum;
    newStatus?: EnrollmentStatusEnum;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: EnrollmentChangeReasonEnum;

    constructor(data?: IEnrollmentStatusHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.oldStatus = _data["oldStatus"];
            this.newStatus = _data["newStatus"];
            this.changedBy = _data["changedBy"];
            this.changedAt = _data["changedAt"] ? new Date(_data["changedAt"].toString()) : <any>undefined;
            this.changeReason = _data["changeReason"];
        }
    }

    static fromJS(data: any): EnrollmentStatusHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentStatusHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["oldStatus"] = this.oldStatus;
        data["newStatus"] = this.newStatus;
        data["changedBy"] = this.changedBy;
        data["changedAt"] = this.changedAt ? this.changedAt.toISOString() : <any>undefined;
        data["changeReason"] = this.changeReason;
        return data;
    }
}

export interface IEnrollmentStatusHistoryDTO {
    enrollmentId?: string;
    oldStatus?: EnrollmentStatusEnum;
    newStatus?: EnrollmentStatusEnum;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: EnrollmentChangeReasonEnum;
}

export enum EnrollmentChangeReasonEnum {
    NewRecord = "NewRecord",
    StatusUpdate = "StatusUpdate",
    Correction = "Correction",
    WorkflowTransition = "WorkflowTransition",
    DocumentVerification = "DocumentVerification",
}

export class DocumentDTO implements IDocumentDTO {
    documentType?: DocumentTypeEnum;
    filePath?: string;
    uploadedAt?: Date;
    verificationStatus?: VerificationStatusEnum;

    constructor(data?: IDocumentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.filePath = _data["filePath"];
            this.uploadedAt = _data["uploadedAt"] ? new Date(_data["uploadedAt"].toString()) : <any>undefined;
            this.verificationStatus = _data["verificationStatus"];
        }
    }

    static fromJS(data: any): DocumentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["filePath"] = this.filePath;
        data["uploadedAt"] = this.uploadedAt ? this.uploadedAt.toISOString() : <any>undefined;
        data["verificationStatus"] = this.verificationStatus;
        return data;
    }
}

export interface IDocumentDTO {
    documentType?: DocumentTypeEnum;
    filePath?: string;
    uploadedAt?: Date;
    verificationStatus?: VerificationStatusEnum;
}

export enum VerificationStatusEnum {
    Pending = "Pending",
    Verified = "Verified",
    Rejected = "Rejected",
}

export class EnrollmentDetailDTO extends EnrollmentDTO implements IEnrollmentDetailDTO {
    studentName?: string;
    branchName?: string;
    documents?: DocumentDTO[];

    constructor(data?: IEnrollmentDetailDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.studentName = _data["studentName"];
            this.branchName = _data["branchName"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnrollmentDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["branchName"] = this.branchName;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEnrollmentDetailDTO extends IEnrollmentDTO {
    studentName?: string;
    branchName?: string;
    documents?: DocumentDTO[];
}

export class GradeStatisticsDTO implements IGradeStatisticsDTO {
    averageScore?: number;
    maxScore?: number;
    minScore?: number;
    gradeDistribution?: GradeDistributionDTO[];

    constructor(data?: IGradeStatisticsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.averageScore = _data["averageScore"];
            this.maxScore = _data["maxScore"];
            this.minScore = _data["minScore"];
            if (Array.isArray(_data["gradeDistribution"])) {
                this.gradeDistribution = [] as any;
                for (let item of _data["gradeDistribution"])
                    this.gradeDistribution!.push(GradeDistributionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeStatisticsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeStatisticsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageScore"] = this.averageScore;
        data["maxScore"] = this.maxScore;
        data["minScore"] = this.minScore;
        if (Array.isArray(this.gradeDistribution)) {
            data["gradeDistribution"] = [];
            for (let item of this.gradeDistribution)
                data["gradeDistribution"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGradeStatisticsDTO {
    averageScore?: number;
    maxScore?: number;
    minScore?: number;
    gradeDistribution?: GradeDistributionDTO[];
}

export class GradeDistributionDTO implements IGradeDistributionDTO {
    gradeType?: GradeTypeEnum;
    count?: number;
    average?: number;

    constructor(data?: IGradeDistributionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeType = _data["gradeType"];
            this.count = _data["count"];
            this.average = _data["average"];
        }
    }

    static fromJS(data: any): GradeDistributionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDistributionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeType"] = this.gradeType;
        data["count"] = this.count;
        data["average"] = this.average;
        return data;
    }
}

export interface IGradeDistributionDTO {
    gradeType?: GradeTypeEnum;
    count?: number;
    average?: number;
}

export enum GradeTypeEnum {
    Exam = "Exam",
    Assignment = "Assignment",
    Quiz = "Quiz",
    OralTest = "OralTest",
}

export class GradeFilterDTO implements IGradeFilterDTO {
    studentId?: string | undefined;
    courseId?: string | undefined;
    semesterId?: string | undefined;
    minScore?: number | undefined;
    maxScore?: number | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IGradeFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.courseId = _data["courseId"];
            this.semesterId = _data["semesterId"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GradeFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["courseId"] = this.courseId;
        data["semesterId"] = this.semesterId;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IGradeFilterDTO {
    studentId?: string | undefined;
    courseId?: string | undefined;
    semesterId?: string | undefined;
    minScore?: number | undefined;
    maxScore?: number | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export class PagedResultOfGradeDTO extends PagedResultBase implements IPagedResultOfGradeDTO {
    results?: GradeDTO[];

    constructor(data?: IPagedResultOfGradeDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GradeDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfGradeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfGradeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfGradeDTO extends IPagedResultBase {
    results?: GradeDTO[];
}

export class GradeDTO implements IGradeDTO {
    id?: string;
    studentId?: string;
    courseId?: string;
    semesterId?: string;
    score?: number;
    gradeType?: GradeTypeEnum;
    teacherCommentFr?: string | undefined;
    teacherCommentAr?: string | undefined;
    teacherCommentEn?: string | undefined;

    constructor(data?: IGradeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.courseId = _data["courseId"];
            this.semesterId = _data["semesterId"];
            this.score = _data["score"];
            this.gradeType = _data["gradeType"];
            this.teacherCommentFr = _data["teacherCommentFr"];
            this.teacherCommentAr = _data["teacherCommentAr"];
            this.teacherCommentEn = _data["teacherCommentEn"];
        }
    }

    static fromJS(data: any): GradeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["courseId"] = this.courseId;
        data["semesterId"] = this.semesterId;
        data["score"] = this.score;
        data["gradeType"] = this.gradeType;
        data["teacherCommentFr"] = this.teacherCommentFr;
        data["teacherCommentAr"] = this.teacherCommentAr;
        data["teacherCommentEn"] = this.teacherCommentEn;
        return data;
    }
}

export interface IGradeDTO {
    id?: string;
    studentId?: string;
    courseId?: string;
    semesterId?: string;
    score?: number;
    gradeType?: GradeTypeEnum;
    teacherCommentFr?: string | undefined;
    teacherCommentAr?: string | undefined;
    teacherCommentEn?: string | undefined;
}

export class PagedResultOfGradeHistoryDTO extends PagedResultBase implements IPagedResultOfGradeHistoryDTO {
    results?: GradeHistoryDTO[];

    constructor(data?: IPagedResultOfGradeHistoryDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GradeHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfGradeHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfGradeHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfGradeHistoryDTO extends IPagedResultBase {
    results?: GradeHistoryDTO[];
}

export class GradeHistoryDTO implements IGradeHistoryDTO {
    gradeId?: string;
    oldScore?: number;
    newScore?: number;
    modifiedBy?: string;
    modifiedAt?: Date;

    constructor(data?: IGradeHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.oldScore = _data["oldScore"];
            this.newScore = _data["newScore"];
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GradeHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["oldScore"] = this.oldScore;
        data["newScore"] = this.newScore;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGradeHistoryDTO {
    gradeId?: string;
    oldScore?: number;
    newScore?: number;
    modifiedBy?: string;
    modifiedAt?: Date;
}

export class GradeHistoryFilterDTO implements IGradeHistoryFilterDTO {
    gradeId?: string;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IGradeHistoryFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GradeHistoryFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeHistoryFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IGradeHistoryFilterDTO {
    gradeId?: string;
    pageNumber?: number;
    pageSize?: number;
}

export class GpaDTO implements IGpaDTO {
    studentId?: string;
    gpa?: number;

    constructor(data?: IGpaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gpa = _data["gpa"];
        }
    }

    static fromJS(data: any): GpaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GpaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gpa"] = this.gpa;
        return data;
    }
}

export interface IGpaDTO {
    studentId?: string;
    gpa?: number;
}

export class TransferRequestDTO implements ITransferRequestDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    status?: TransferRequestStatus;
    documents?: DocumentDTO[] | undefined;
    reason?: string | undefined;
    submittedAt?: Date;
    adminComment?: string | undefined;

    constructor(data?: ITransferRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fromBranchId = _data["fromBranchId"];
            this.toBranchId = _data["toBranchId"];
            this.fromSchoolId = _data["fromSchoolId"];
            this.toSchoolId = _data["toSchoolId"];
            this.status = _data["status"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
            this.reason = _data["reason"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            this.adminComment = _data["adminComment"];
        }
    }

    static fromJS(data: any): TransferRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fromBranchId"] = this.fromBranchId;
        data["toBranchId"] = this.toBranchId;
        data["fromSchoolId"] = this.fromSchoolId;
        data["toSchoolId"] = this.toSchoolId;
        data["status"] = this.status;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["reason"] = this.reason;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["adminComment"] = this.adminComment;
        return data;
    }
}

export interface ITransferRequestDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    status?: TransferRequestStatus;
    documents?: DocumentDTO[] | undefined;
    reason?: string | undefined;
    submittedAt?: Date;
    adminComment?: string | undefined;
}

export enum TransferRequestStatus {
    None = "None",
    Pending = "Pending",
    UnderReview = "UnderReview",
    Approved = "Approved",
    Rejected = "Rejected",
    Completed = "Completed",
    Canceled = "Canceled",
}

export class PagedResultOfTransferRequestHistoryDTO extends PagedResultBase implements IPagedResultOfTransferRequestHistoryDTO {
    results?: TransferRequestHistoryDTO[];

    constructor(data?: IPagedResultOfTransferRequestHistoryDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TransferRequestHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfTransferRequestHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfTransferRequestHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfTransferRequestHistoryDTO extends IPagedResultBase {
    results?: TransferRequestHistoryDTO[];
}

export class TransferRequestHistoryDTO implements ITransferRequestHistoryDTO {
    transferRequestId?: string;
    oldStatus?: TransferRequestStatus;
    newStatus?: TransferRequestStatus;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: TransferRequestChangeReasonEnum;
    reason?: string;

    constructor(data?: ITransferRequestHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferRequestId = _data["transferRequestId"];
            this.oldStatus = _data["oldStatus"];
            this.newStatus = _data["newStatus"];
            this.changedBy = _data["changedBy"];
            this.changedAt = _data["changedAt"] ? new Date(_data["changedAt"].toString()) : <any>undefined;
            this.changeReason = _data["changeReason"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): TransferRequestHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRequestHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferRequestId"] = this.transferRequestId;
        data["oldStatus"] = this.oldStatus;
        data["newStatus"] = this.newStatus;
        data["changedBy"] = this.changedBy;
        data["changedAt"] = this.changedAt ? this.changedAt.toISOString() : <any>undefined;
        data["changeReason"] = this.changeReason;
        data["reason"] = this.reason;
        return data;
    }
}

export interface ITransferRequestHistoryDTO {
    transferRequestId?: string;
    oldStatus?: TransferRequestStatus;
    newStatus?: TransferRequestStatus;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: TransferRequestChangeReasonEnum;
    reason?: string;
}

export enum TransferRequestChangeReasonEnum {
    NewRequest = "NewRequest",
    ReEvaluated = "ReEvaluated",
    Edited = "Edited",
    Other = "Other",
    Reassignment = "Reassignment",
    Canceled = "Canceled",
}

export class TransferHistoryFilterDTO implements ITransferHistoryFilterDTO {
    transferRequestId?: string;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: ITransferHistoryFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferRequestId = _data["transferRequestId"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): TransferHistoryFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferHistoryFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferRequestId"] = this.transferRequestId;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface ITransferHistoryFilterDTO {
    transferRequestId?: string;
    pageNumber?: number;
    pageSize?: number;
}

export class TransferRequestDetailDTO implements ITransferRequestDetailDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    reason?: string | undefined;
    status?: TransferRequestStatus;
    submittedAt?: Date;
    documents?: DocumentDTO[];
    history?: TransferRequestHistoryDTO[];

    constructor(data?: ITransferRequestDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fromBranchId = _data["fromBranchId"];
            this.toBranchId = _data["toBranchId"];
            this.fromSchoolId = _data["fromSchoolId"];
            this.toSchoolId = _data["toSchoolId"];
            this.reason = _data["reason"];
            this.status = _data["status"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(TransferRequestHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransferRequestDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRequestDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fromBranchId"] = this.fromBranchId;
        data["toBranchId"] = this.toBranchId;
        data["fromSchoolId"] = this.fromSchoolId;
        data["toSchoolId"] = this.toSchoolId;
        data["reason"] = this.reason;
        data["status"] = this.status;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransferRequestDetailDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    reason?: string | undefined;
    status?: TransferRequestStatus;
    submittedAt?: Date;
    documents?: DocumentDTO[];
    history?: TransferRequestHistoryDTO[];
}

export class TransferEligibilityResultDTO implements ITransferEligibilityResultDTO {
    isEligible?: boolean;
    pendingFees?: boolean;
    disciplinaryIssues?: boolean;

    constructor(data?: ITransferEligibilityResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEligible = _data["isEligible"];
            this.pendingFees = _data["pendingFees"];
            this.disciplinaryIssues = _data["disciplinaryIssues"];
        }
    }

    static fromJS(data: any): TransferEligibilityResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferEligibilityResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEligible"] = this.isEligible;
        data["pendingFees"] = this.pendingFees;
        data["disciplinaryIssues"] = this.disciplinaryIssues;
        return data;
    }
}

export interface ITransferEligibilityResultDTO {
    isEligible?: boolean;
    pendingFees?: boolean;
    disciplinaryIssues?: boolean;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class AppException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isAppException = true;

    static isAppException(obj: any): obj is AppException {
        return obj.isAppException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new AppException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}