//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IAcademicsClient {
    getCurrentYear(): Promise<AcademicYearDTO>;
    getSemester(yearId: string | undefined, filter: FilterSemesterDTO): Promise<PagedResultOfSemesterDTO>;
}

export class AcademicsClient implements IAcademicsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getCurrentYear( cancelToken?: CancelToken): Promise<AcademicYearDTO> {
        let url_ = this.baseUrl + "/academics/getcurrentyear";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentYear(_response);
        });
    }

    protected processGetCurrentYear(response: AxiosResponse): Promise<AcademicYearDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AcademicYearDTO.fromJS(resultData200);
            return Promise.resolve<AcademicYearDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AcademicYearDTO>(null as any);
    }

    getSemester(yearId: string | undefined, filter: FilterSemesterDTO, cancelToken?: CancelToken): Promise<PagedResultOfSemesterDTO> {
        let url_ = this.baseUrl + "/academics/getsemesters?";
        if (yearId === null)
            throw new Error("The parameter 'yearId' cannot be null.");
        else if (yearId !== undefined)
            url_ += "YearId=" + encodeURIComponent("" + yearId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSemester(_response);
        });
    }

    protected processGetSemester(response: AxiosResponse): Promise<PagedResultOfSemesterDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfSemesterDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfSemesterDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfSemesterDTO>(null as any);
    }
}

export interface IAttendanceClient {
    getById(id: string): Promise<AttendanceDTO>;
    updateAttendance(id: string, reason: AttendanceChangeReasonEnum | undefined, data: AttendanceDTO): Promise<boolean>;
    deleteAttendance(id: string): Promise<boolean>;
    getPaginatedRecords(studentId: string | null | undefined, courseId: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, status: AttendanceEnum | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfAttendanceDTO>;
    recordAttendance(data: AttendanceDTO): Promise<boolean>;
    getSummary(studentId: string, startDate: Date | undefined, endDate: Date | undefined): Promise<AttendanceSummaryDTO>;
}

export class AttendanceClient implements IAttendanceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getById(id: string, cancelToken?: CancelToken): Promise<AttendanceDTO> {
        let url_ = this.baseUrl + "/attendance/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<AttendanceDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttendanceDTO.fromJS(resultData200);
            return Promise.resolve<AttendanceDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttendanceDTO>(null as any);
    }

    updateAttendance(id: string, reason: AttendanceChangeReasonEnum | undefined, data: AttendanceDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/attendance/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (reason === null)
            throw new Error("The parameter 'reason' cannot be null.");
        else if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAttendance(_response);
        });
    }

    protected processUpdateAttendance(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    deleteAttendance(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/attendance/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAttendance(_response);
        });
    }

    protected processDeleteAttendance(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginatedRecords(studentId: string | null | undefined, courseId: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, status: AttendanceEnum | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfAttendanceDTO> {
        let url_ = this.baseUrl + "/attendance/records?";
        if (studentId !== undefined && studentId !== null)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (courseId !== undefined && courseId !== null)
            url_ += "CourseId=" + encodeURIComponent("" + courseId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedRecords(_response);
        });
    }

    protected processGetPaginatedRecords(response: AxiosResponse): Promise<PagedResultOfAttendanceDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfAttendanceDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfAttendanceDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfAttendanceDTO>(null as any);
    }

    recordAttendance(data: AttendanceDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/attendance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecordAttendance(_response);
        });
    }

    protected processRecordAttendance(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getSummary(studentId: string, startDate: Date | undefined, endDate: Date | undefined, cancelToken?: CancelToken): Promise<AttendanceSummaryDTO> {
        let url_ = this.baseUrl + "/attendance/summary/{studentId}?";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{studentId}", encodeURIComponent("" + studentId));
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: AxiosResponse): Promise<AttendanceSummaryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttendanceSummaryDTO.fromJS(resultData200);
            return Promise.resolve<AttendanceSummaryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttendanceSummaryDTO>(null as any);
    }
}

export interface ICoursesClient {
    getById(id: string): Promise<CourseDTO>;
    update(id: string, dto: CourseDTO): Promise<boolean>;
    delete(id: string): Promise<boolean>;
    getPaginated(searchTerm: string | undefined, gradeLevelId: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfCourseDTO>;
    create(dto: CourseDTO): Promise<boolean>;
    getByGrade(gradeLevelId: string): Promise<CourseDTO[]>;
}

export class CoursesClient implements ICoursesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getById(id: string, cancelToken?: CancelToken): Promise<CourseDTO> {
        let url_ = this.baseUrl + "/courses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CourseDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CourseDTO.fromJS(resultData200);
            return Promise.resolve<CourseDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseDTO>(null as any);
    }

    update(id: string, dto: CourseDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/courses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    delete(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/courses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginated(searchTerm: string | undefined, gradeLevelId: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfCourseDTO> {
        let url_ = this.baseUrl + "/courses?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (gradeLevelId !== undefined && gradeLevelId !== null)
            url_ += "GradeLevelId=" + encodeURIComponent("" + gradeLevelId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfCourseDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfCourseDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfCourseDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfCourseDTO>(null as any);
    }

    create(dto: CourseDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/courses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getByGrade(gradeLevelId: string, cancelToken?: CancelToken): Promise<CourseDTO[]> {
        let url_ = this.baseUrl + "/courses/bygrade/{gradeLevelId}";
        if (gradeLevelId === undefined || gradeLevelId === null)
            throw new Error("The parameter 'gradeLevelId' must be defined.");
        url_ = url_.replace("{gradeLevelId}", encodeURIComponent("" + gradeLevelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByGrade(_response);
        });
    }

    protected processGetByGrade(response: AxiosResponse): Promise<CourseDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CourseDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseDTO[]>(null as any);
    }
}

export interface IEnrollmentClient {
    submitEnrollment(dto: EnrollmentDTO): Promise<boolean>;
    getPaginated(branchId: string | null | undefined, status: EnrollmentStatusEnum | null | undefined, createdFrom: Date | null | undefined, createdTo: Date | null | undefined, searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfEnrollmentDTO>;
    getEnrollment(id: string): Promise<EnrollmentDetailDTO>;
    updateStatus(id: string, dto: EnrollmentStatusUpdateDTO): Promise<boolean>;
    createRequest(dto: CreateEnrollmentRequestDTO): Promise<string>;
    getEnrollmentRequests(status: EnrollmentRequestStatusEnum | null | undefined, branchId: string | null | undefined, parentId: string | null | undefined, searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<PagedResultOfEnrollmentRequestDTO>;
    getEnrollmentRequestById(idPath: string, idBody: string): Promise<EnrollmentRequestDetailDTO>;
    updateRequest(requestId: string, dto: UpdateEnrollmentRequestDTO): Promise<boolean>;
    submitEnrollmentRequest(requestId: string): Promise<boolean>;
    approveEnrollmentRequest(adminUserId: string | undefined, requestId: string): Promise<boolean>;
    bulkApproveEnrollmentRequest(adminUserId: string | undefined, requestIds: string[]): Promise<boolean>;
    saveRequest(request: EnrollmentRequestDTO): Promise<boolean>;
    getDashboardMetrics(startDate: Date | undefined, endDate: Date | undefined): Promise<EnrollmentMetricsDTO>;
}

export class EnrollmentClient implements IEnrollmentClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    submitEnrollment(dto: EnrollmentDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitEnrollment(_response);
        });
    }

    protected processSubmitEnrollment(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginated(branchId: string | null | undefined, status: EnrollmentStatusEnum | null | undefined, createdFrom: Date | null | undefined, createdTo: Date | null | undefined, searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfEnrollmentDTO> {
        let url_ = this.baseUrl + "/enrollment?";
        if (branchId !== undefined && branchId !== null)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (createdFrom !== undefined && createdFrom !== null)
            url_ += "CreatedFrom=" + encodeURIComponent(createdFrom ? "" + createdFrom.toISOString() : "") + "&";
        if (createdTo !== undefined && createdTo !== null)
            url_ += "CreatedTo=" + encodeURIComponent(createdTo ? "" + createdTo.toISOString() : "") + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfEnrollmentDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfEnrollmentDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfEnrollmentDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfEnrollmentDTO>(null as any);
    }

    getEnrollment(id: string, cancelToken?: CancelToken): Promise<EnrollmentDetailDTO> {
        let url_ = this.baseUrl + "/enrollment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnrollment(_response);
        });
    }

    protected processGetEnrollment(response: AxiosResponse): Promise<EnrollmentDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnrollmentDetailDTO.fromJS(resultData200);
            return Promise.resolve<EnrollmentDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EnrollmentDetailDTO>(null as any);
    }

    updateStatus(id: string, dto: EnrollmentStatusUpdateDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    createRequest(dto: CreateEnrollmentRequestDTO, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/enrollment/createrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRequest(_response);
        });
    }

    protected processCreateRequest(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getEnrollmentRequests(status: EnrollmentRequestStatusEnum | null | undefined, branchId: string | null | undefined, parentId: string | null | undefined, searchTerm: string | null | undefined, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfEnrollmentRequestDTO> {
        let url_ = this.baseUrl + "/enrollment/getenrollmentrequests?";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (branchId !== undefined && branchId !== null)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnrollmentRequests(_response);
        });
    }

    protected processGetEnrollmentRequests(response: AxiosResponse): Promise<PagedResultOfEnrollmentRequestDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfEnrollmentRequestDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfEnrollmentRequestDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfEnrollmentRequestDTO>(null as any);
    }

    getEnrollmentRequestById(idPath: string, idBody: string, cancelToken?: CancelToken): Promise<EnrollmentRequestDetailDTO> {
        let url_ = this.baseUrl + "/enrollment/getenrollmentrequestbyid/{Id}";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idBody);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnrollmentRequestById(_response);
        });
    }

    protected processGetEnrollmentRequestById(response: AxiosResponse): Promise<EnrollmentRequestDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnrollmentRequestDetailDTO.fromJS(resultData200);
            return Promise.resolve<EnrollmentRequestDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EnrollmentRequestDetailDTO>(null as any);
    }

    updateRequest(requestId: string, dto: UpdateEnrollmentRequestDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/updaterequest/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRequest(_response);
        });
    }

    protected processUpdateRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    submitEnrollmentRequest(requestId: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/submitenrollmentrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitEnrollmentRequest(_response);
        });
    }

    protected processSubmitEnrollmentRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    approveEnrollmentRequest(adminUserId: string | undefined, requestId: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/approveenrollmentrequest?";
        if (adminUserId === null)
            throw new Error("The parameter 'adminUserId' cannot be null.");
        else if (adminUserId !== undefined)
            url_ += "adminUserId=" + encodeURIComponent("" + adminUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApproveEnrollmentRequest(_response);
        });
    }

    protected processApproveEnrollmentRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    bulkApproveEnrollmentRequest(adminUserId: string | undefined, requestIds: string[], cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/bulkapproveenrollmentrequest?";
        if (adminUserId === null)
            throw new Error("The parameter 'adminUserId' cannot be null.");
        else if (adminUserId !== undefined)
            url_ += "adminUserId=" + encodeURIComponent("" + adminUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkApproveEnrollmentRequest(_response);
        });
    }

    protected processBulkApproveEnrollmentRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    saveRequest(request: EnrollmentRequestDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/enrollment/saverequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveRequest(_response);
        });
    }

    protected processSaveRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getDashboardMetrics(startDate: Date | undefined, endDate: Date | undefined, cancelToken?: CancelToken): Promise<EnrollmentMetricsDTO> {
        let url_ = this.baseUrl + "/enrollment/dashboard?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboardMetrics(_response);
        });
    }

    protected processGetDashboardMetrics(response: AxiosResponse): Promise<EnrollmentMetricsDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnrollmentMetricsDTO.fromJS(resultData200);
            return Promise.resolve<EnrollmentMetricsDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EnrollmentMetricsDTO>(null as any);
    }
}

export interface IFrontofficeServicesClient {
    getCurrentYear(): Promise<AcademicYearDTO>;
    getAttendanceRecords(studentId: string): Promise<AttendanceDTO[]>;
    getAttendanceSummary(studentId: string | undefined, data: DateRangeDTO): Promise<AttendanceSummaryDTO>;
    submitAttendanceExcuse(studentId: string | undefined, data: AttendanceExcuseDTO): Promise<boolean>;
    getCourseDetails(courseId: string): Promise<CourseDetailDTO>;
    getCoursesByGradeLevel(gradeLevelId: string): Promise<CourseDTO[]>;
    getEnrollment(id: string): Promise<EnrollmentDetailDTO>;
    getEnrollmentTranscript(id: string): Promise<EnrollmentTranscriptDTO>;
    submitEnrollment(data: EnrollmentDTO): Promise<boolean>;
    uploadEnrollmentDocument(data: EnrollmentDocumentUploadDTO): Promise<boolean>;
    getGradeHistory(data: GradeHistoryFilterDTO): Promise<PagedResultOfGradeHistoryDTO>;
    getGrade(data: GradeFilterDTO): Promise<PagedResultOfGradeDTO>;
    getGradeStatistics(data: GradeFilterDTO): Promise<GradeStatisticsDTO>;
    getStudentGPA(studentId: string): Promise<GpaDTO>;
    getGraderResources(data: ResourceFilterDTO): Promise<PagedResultOfGradeResourceDTO>;
    getScheduleByGradeSection(gradeSectionId: string): Promise<ScheduleDTO[]>;
    cancelTransferRequest(requestId: string): Promise<boolean>;
    checkTransferEligibility(studentId: string): Promise<TransferEligibilityResultDTO>;
    getTransferDetails(requestId: string): Promise<TransferRequestDetailDTO>;
    getTransferHistory(data: TransferHistoryFilterDTO): Promise<PagedResultOfTransferRequestHistoryDTO>;
    submitTransferRequest(request: TransferRequestDTO): Promise<boolean>;
    getPaginatedAttendanceHistory(data: AttendanceHistoryFilterDTO): Promise<PagedResultOfAttendanceHistoryDTO>;
}

export class FrontofficeServicesClient implements IFrontofficeServicesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getCurrentYear( cancelToken?: CancelToken): Promise<AcademicYearDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getcurrentyear";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentYear(_response);
        });
    }

    protected processGetCurrentYear(response: AxiosResponse): Promise<AcademicYearDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AcademicYearDTO.fromJS(resultData200);
            return Promise.resolve<AcademicYearDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AcademicYearDTO>(null as any);
    }

    getAttendanceRecords(studentId: string, cancelToken?: CancelToken): Promise<AttendanceDTO[]> {
        let url_ = this.baseUrl + "/frontofficeservices/getattendancerecords/{StudentId}";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{StudentId}", encodeURIComponent("" + studentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAttendanceRecords(_response);
        });
    }

    protected processGetAttendanceRecords(response: AxiosResponse): Promise<AttendanceDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttendanceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttendanceDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttendanceDTO[]>(null as any);
    }

    getAttendanceSummary(studentId: string | undefined, data: DateRangeDTO, cancelToken?: CancelToken): Promise<AttendanceSummaryDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getattendancesummary?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAttendanceSummary(_response);
        });
    }

    protected processGetAttendanceSummary(response: AxiosResponse): Promise<AttendanceSummaryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttendanceSummaryDTO.fromJS(resultData200);
            return Promise.resolve<AttendanceSummaryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttendanceSummaryDTO>(null as any);
    }

    submitAttendanceExcuse(studentId: string | undefined, data: AttendanceExcuseDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/frontofficeservices/submitattendanceexcuse?";
        if (studentId === null)
            throw new Error("The parameter 'studentId' cannot be null.");
        else if (studentId !== undefined)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitAttendanceExcuse(_response);
        });
    }

    protected processSubmitAttendanceExcuse(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getCourseDetails(courseId: string, cancelToken?: CancelToken): Promise<CourseDetailDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getcoursedetails/{CourseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{CourseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCourseDetails(_response);
        });
    }

    protected processGetCourseDetails(response: AxiosResponse): Promise<CourseDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CourseDetailDTO.fromJS(resultData200);
            return Promise.resolve<CourseDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseDetailDTO>(null as any);
    }

    getCoursesByGradeLevel(gradeLevelId: string, cancelToken?: CancelToken): Promise<CourseDTO[]> {
        let url_ = this.baseUrl + "/frontofficeservices/getcoursesbygradelevel/{GradeLevelId}";
        if (gradeLevelId === undefined || gradeLevelId === null)
            throw new Error("The parameter 'gradeLevelId' must be defined.");
        url_ = url_.replace("{GradeLevelId}", encodeURIComponent("" + gradeLevelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCoursesByGradeLevel(_response);
        });
    }

    protected processGetCoursesByGradeLevel(response: AxiosResponse): Promise<CourseDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CourseDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseDTO[]>(null as any);
    }

    getEnrollment(id: string, cancelToken?: CancelToken): Promise<EnrollmentDetailDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getenrollment/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnrollment(_response);
        });
    }

    protected processGetEnrollment(response: AxiosResponse): Promise<EnrollmentDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnrollmentDetailDTO.fromJS(resultData200);
            return Promise.resolve<EnrollmentDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EnrollmentDetailDTO>(null as any);
    }

    getEnrollmentTranscript(id: string, cancelToken?: CancelToken): Promise<EnrollmentTranscriptDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getenrollmenttranscript/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnrollmentTranscript(_response);
        });
    }

    protected processGetEnrollmentTranscript(response: AxiosResponse): Promise<EnrollmentTranscriptDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EnrollmentTranscriptDTO.fromJS(resultData200);
            return Promise.resolve<EnrollmentTranscriptDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EnrollmentTranscriptDTO>(null as any);
    }

    submitEnrollment(data: EnrollmentDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/frontofficeservices/submitenrollment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitEnrollment(_response);
        });
    }

    protected processSubmitEnrollment(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    uploadEnrollmentDocument(data: EnrollmentDocumentUploadDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/frontofficeservices/uploadenrollmentdocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadEnrollmentDocument(_response);
        });
    }

    protected processUploadEnrollmentDocument(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getGradeHistory(data: GradeHistoryFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfGradeHistoryDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getgradehistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGradeHistory(_response);
        });
    }

    protected processGetGradeHistory(response: AxiosResponse): Promise<PagedResultOfGradeHistoryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeHistoryDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeHistoryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeHistoryDTO>(null as any);
    }

    getGrade(data: GradeFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfGradeDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getgrade";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGrade(_response);
        });
    }

    protected processGetGrade(response: AxiosResponse): Promise<PagedResultOfGradeDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeDTO>(null as any);
    }

    getGradeStatistics(data: GradeFilterDTO, cancelToken?: CancelToken): Promise<GradeStatisticsDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getgradestatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGradeStatistics(_response);
        });
    }

    protected processGetGradeStatistics(response: AxiosResponse): Promise<GradeStatisticsDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GradeStatisticsDTO.fromJS(resultData200);
            return Promise.resolve<GradeStatisticsDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GradeStatisticsDTO>(null as any);
    }

    getStudentGPA(studentId: string, cancelToken?: CancelToken): Promise<GpaDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getstudentgpa/{StudentId}";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{StudentId}", encodeURIComponent("" + studentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudentGPA(_response);
        });
    }

    protected processGetStudentGPA(response: AxiosResponse): Promise<GpaDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GpaDTO.fromJS(resultData200);
            return Promise.resolve<GpaDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GpaDTO>(null as any);
    }

    getGraderResources(data: ResourceFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfGradeResourceDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getgraderresources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGraderResources(_response);
        });
    }

    protected processGetGraderResources(response: AxiosResponse): Promise<PagedResultOfGradeResourceDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeResourceDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeResourceDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeResourceDTO>(null as any);
    }

    getScheduleByGradeSection(gradeSectionId: string, cancelToken?: CancelToken): Promise<ScheduleDTO[]> {
        let url_ = this.baseUrl + "/frontofficeservices/getschedulebygradesection/{GradeSectionId}";
        if (gradeSectionId === undefined || gradeSectionId === null)
            throw new Error("The parameter 'gradeSectionId' must be defined.");
        url_ = url_.replace("{GradeSectionId}", encodeURIComponent("" + gradeSectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetScheduleByGradeSection(_response);
        });
    }

    protected processGetScheduleByGradeSection(response: AxiosResponse): Promise<ScheduleDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScheduleDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ScheduleDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduleDTO[]>(null as any);
    }

    cancelTransferRequest(requestId: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/frontofficeservices/canceltransferrequest/{RequestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{RequestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelTransferRequest(_response);
        });
    }

    protected processCancelTransferRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    checkTransferEligibility(studentId: string, cancelToken?: CancelToken): Promise<TransferEligibilityResultDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/checktransfereligibility/{StudentId}";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{StudentId}", encodeURIComponent("" + studentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckTransferEligibility(_response);
        });
    }

    protected processCheckTransferEligibility(response: AxiosResponse): Promise<TransferEligibilityResultDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransferEligibilityResultDTO.fromJS(resultData200);
            return Promise.resolve<TransferEligibilityResultDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferEligibilityResultDTO>(null as any);
    }

    getTransferDetails(requestId: string, cancelToken?: CancelToken): Promise<TransferRequestDetailDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/gettransferdetails/{RequestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{RequestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTransferDetails(_response);
        });
    }

    protected processGetTransferDetails(response: AxiosResponse): Promise<TransferRequestDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransferRequestDetailDTO.fromJS(resultData200);
            return Promise.resolve<TransferRequestDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferRequestDetailDTO>(null as any);
    }

    getTransferHistory(data: TransferHistoryFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfTransferRequestHistoryDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/gettransferhistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTransferHistory(_response);
        });
    }

    protected processGetTransferHistory(response: AxiosResponse): Promise<PagedResultOfTransferRequestHistoryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfTransferRequestHistoryDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfTransferRequestHistoryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfTransferRequestHistoryDTO>(null as any);
    }

    submitTransferRequest(request: TransferRequestDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/frontofficeservices/submittransferrequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitTransferRequest(_response);
        });
    }

    protected processSubmitTransferRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginatedAttendanceHistory(data: AttendanceHistoryFilterDTO, cancelToken?: CancelToken): Promise<PagedResultOfAttendanceHistoryDTO> {
        let url_ = this.baseUrl + "/frontofficeservices/getpaginatedattendancehistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedAttendanceHistory(_response);
        });
    }

    protected processGetPaginatedAttendanceHistory(response: AxiosResponse): Promise<PagedResultOfAttendanceHistoryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfAttendanceHistoryDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfAttendanceHistoryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfAttendanceHistoryDTO>(null as any);
    }
}

export interface IGradeLevelClient {
    getById(id: string): Promise<GradeLevelDTO>;
    update(id: string, data: GradeLevelDTO): Promise<boolean>;
    delete(id: string): Promise<boolean>;
    getLevelByES(stage: EducationalStageEnum | undefined, page: number | undefined, size: number | null | undefined): Promise<PagedResultOfGradeLevelDTO>;
    create(data: GradeLevelDTO): Promise<boolean>;
    getByName(name: string | undefined): Promise<GradeLevelDTO>;
}

export class GradeLevelClient implements IGradeLevelClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getById(id: string, cancelToken?: CancelToken): Promise<GradeLevelDTO> {
        let url_ = this.baseUrl + "/gradelevel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<GradeLevelDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GradeLevelDTO.fromJS(resultData200);
            return Promise.resolve<GradeLevelDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GradeLevelDTO>(null as any);
    }

    update(id: string, data: GradeLevelDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/gradelevel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    delete(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/gradelevel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getLevelByES(stage: EducationalStageEnum | undefined, page: number | undefined, size: number | null | undefined, cancelToken?: CancelToken): Promise<PagedResultOfGradeLevelDTO> {
        let url_ = this.baseUrl + "/gradelevel/getbyeducationalstage?";
        if (stage === null)
            throw new Error("The parameter 'stage' cannot be null.");
        else if (stage !== undefined)
            url_ += "Stage=" + encodeURIComponent("" + stage) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size !== undefined && size !== null)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLevelByES(_response);
        });
    }

    protected processGetLevelByES(response: AxiosResponse): Promise<PagedResultOfGradeLevelDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeLevelDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeLevelDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeLevelDTO>(null as any);
    }

    create(data: GradeLevelDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/gradelevel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getByName(name: string | undefined, cancelToken?: CancelToken): Promise<GradeLevelDTO> {
        let url_ = this.baseUrl + "/gradelevel/getbyname?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByName(_response);
        });
    }

    protected processGetByName(response: AxiosResponse): Promise<GradeLevelDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GradeLevelDTO.fromJS(resultData200);
            return Promise.resolve<GradeLevelDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GradeLevelDTO>(null as any);
    }
}

export interface IGradesClient {
    recordGrade(dto: GradeDTO): Promise<boolean>;
    getPaginated(studentId: string | null | undefined, courseId: string | null | undefined, semesterId: string | null | undefined, minScore: number | null | undefined, maxScore: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfGradeDTO>;
    updateGrade(id: string, dto: GradeUpdateDTO): Promise<boolean>;
    bulkRecordGrades(dto: BulkGradeDTO): Promise<boolean>;
    getStatistics(studentId: string | null | undefined, courseId: string | null | undefined, semesterId: string | null | undefined, minScore: number | null | undefined, maxScore: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<GradeStatisticsDTO>;
    calculateGPA(studentId: string): Promise<GpaDTO>;
}

export class GradesClient implements IGradesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    recordGrade(dto: GradeDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/grades";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecordGrade(_response);
        });
    }

    protected processRecordGrade(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginated(studentId: string | null | undefined, courseId: string | null | undefined, semesterId: string | null | undefined, minScore: number | null | undefined, maxScore: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfGradeDTO> {
        let url_ = this.baseUrl + "/grades?";
        if (studentId !== undefined && studentId !== null)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (courseId !== undefined && courseId !== null)
            url_ += "CourseId=" + encodeURIComponent("" + courseId) + "&";
        if (semesterId !== undefined && semesterId !== null)
            url_ += "SemesterId=" + encodeURIComponent("" + semesterId) + "&";
        if (minScore !== undefined && minScore !== null)
            url_ += "MinScore=" + encodeURIComponent("" + minScore) + "&";
        if (maxScore !== undefined && maxScore !== null)
            url_ += "MaxScore=" + encodeURIComponent("" + maxScore) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfGradeDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeDTO>(null as any);
    }

    updateGrade(id: string, dto: GradeUpdateDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/grades/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateGrade(_response);
        });
    }

    protected processUpdateGrade(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    bulkRecordGrades(dto: BulkGradeDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/grades/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkRecordGrades(_response);
        });
    }

    protected processBulkRecordGrades(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getStatistics(studentId: string | null | undefined, courseId: string | null | undefined, semesterId: string | null | undefined, minScore: number | null | undefined, maxScore: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<GradeStatisticsDTO> {
        let url_ = this.baseUrl + "/grades/statistics?";
        if (studentId !== undefined && studentId !== null)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (courseId !== undefined && courseId !== null)
            url_ += "CourseId=" + encodeURIComponent("" + courseId) + "&";
        if (semesterId !== undefined && semesterId !== null)
            url_ += "SemesterId=" + encodeURIComponent("" + semesterId) + "&";
        if (minScore !== undefined && minScore !== null)
            url_ += "MinScore=" + encodeURIComponent("" + minScore) + "&";
        if (maxScore !== undefined && maxScore !== null)
            url_ += "MaxScore=" + encodeURIComponent("" + maxScore) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatistics(_response);
        });
    }

    protected processGetStatistics(response: AxiosResponse): Promise<GradeStatisticsDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GradeStatisticsDTO.fromJS(resultData200);
            return Promise.resolve<GradeStatisticsDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GradeStatisticsDTO>(null as any);
    }

    calculateGPA(studentId: string, cancelToken?: CancelToken): Promise<GpaDTO> {
        let url_ = this.baseUrl + "/grades/gpa/{studentId}";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{studentId}", encodeURIComponent("" + studentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCalculateGPA(_response);
        });
    }

    protected processCalculateGPA(response: AxiosResponse): Promise<GpaDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GpaDTO.fromJS(resultData200);
            return Promise.resolve<GpaDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GpaDTO>(null as any);
    }
}

export interface IParentsClient {
    createParent(dto: ParentDTO): Promise<boolean>;
    bulkCreateParents(dto: BulkParentDTO): Promise<boolean>;
    getParentById(id: string): Promise<ParentDTO>;
    getParentByUserId(id: string): Promise<ParentDTO>;
    exists(email: string | undefined): Promise<boolean>;
    getPaginated(searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfParentDTO>;
    verifyIdentity(id: string, dto: ParentVerificationDTO): Promise<boolean>;
    getAssociatedStudents(id: string, page: number | undefined, size: number | null | undefined): Promise<PagedResultOfParsedStudentDto>;
}

export class ParentsClient implements IParentsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    createParent(dto: ParentDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/parents/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateParent(_response);
        });
    }

    protected processCreateParent(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    bulkCreateParents(dto: BulkParentDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/parents/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkCreateParents(_response);
        });
    }

    protected processBulkCreateParents(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getParentById(id: string, cancelToken?: CancelToken): Promise<ParentDTO> {
        let url_ = this.baseUrl + "/parents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetParentById(_response);
        });
    }

    protected processGetParentById(response: AxiosResponse): Promise<ParentDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParentDTO.fromJS(resultData200);
            return Promise.resolve<ParentDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParentDTO>(null as any);
    }

    getParentByUserId(id: string, cancelToken?: CancelToken): Promise<ParentDTO> {
        let url_ = this.baseUrl + "/parents/byuserid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetParentByUserId(_response);
        });
    }

    protected processGetParentByUserId(response: AxiosResponse): Promise<ParentDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParentDTO.fromJS(resultData200);
            return Promise.resolve<ParentDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParentDTO>(null as any);
    }

    exists(email: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/parents/exists?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginated(searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfParentDTO> {
        let url_ = this.baseUrl + "/parents?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfParentDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfParentDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfParentDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfParentDTO>(null as any);
    }

    verifyIdentity(id: string, dto: ParentVerificationDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/parents/{id}/verify";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyIdentity(_response);
        });
    }

    protected processVerifyIdentity(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAssociatedStudents(id: string, page: number | undefined, size: number | null | undefined, cancelToken?: CancelToken): Promise<PagedResultOfParsedStudentDto> {
        let url_ = this.baseUrl + "/parents/{id}/students?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size !== undefined && size !== null)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAssociatedStudents(_response);
        });
    }

    protected processGetAssociatedStudents(response: AxiosResponse): Promise<PagedResultOfParsedStudentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfParsedStudentDto.fromJS(resultData200);
            return Promise.resolve<PagedResultOfParsedStudentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfParsedStudentDto>(null as any);
    }
}

export interface IProfileClient {
    getParentDashboard(id: string): Promise<ParentDashboardDTO>;
    getParentProfile(id: string): Promise<ParentProfileDTO>;
    getStudentDashboard(id: string): Promise<StudentDashboardDTO>;
    getStudentProfile(id: string): Promise<StudentProfileDTO>;
    getStaffDashboard(id: string): Promise<StaffDashboardDTO>;
    getStaffProfile(id: string): Promise<StaffProfileDTO>;
    getTeacherDashboard(id: string): Promise<TeacherDashboardDTO>;
    getTeacherProfile(id: string): Promise<TeacherProfileDTO>;
}

export class ProfileClient implements IProfileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getParentDashboard(id: string, cancelToken?: CancelToken): Promise<ParentDashboardDTO> {
        let url_ = this.baseUrl + "/profile/getparentdashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetParentDashboard(_response);
        });
    }

    protected processGetParentDashboard(response: AxiosResponse): Promise<ParentDashboardDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParentDashboardDTO.fromJS(resultData200);
            return Promise.resolve<ParentDashboardDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParentDashboardDTO>(null as any);
    }

    getParentProfile(id: string, cancelToken?: CancelToken): Promise<ParentProfileDTO> {
        let url_ = this.baseUrl + "/profile/getparentprofile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetParentProfile(_response);
        });
    }

    protected processGetParentProfile(response: AxiosResponse): Promise<ParentProfileDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ParentProfileDTO.fromJS(resultData200);
            return Promise.resolve<ParentProfileDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ParentProfileDTO>(null as any);
    }

    getStudentDashboard(id: string, cancelToken?: CancelToken): Promise<StudentDashboardDTO> {
        let url_ = this.baseUrl + "/profile/getstudentdashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudentDashboard(_response);
        });
    }

    protected processGetStudentDashboard(response: AxiosResponse): Promise<StudentDashboardDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StudentDashboardDTO.fromJS(resultData200);
            return Promise.resolve<StudentDashboardDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudentDashboardDTO>(null as any);
    }

    getStudentProfile(id: string, cancelToken?: CancelToken): Promise<StudentProfileDTO> {
        let url_ = this.baseUrl + "/profile/getstudentprofile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudentProfile(_response);
        });
    }

    protected processGetStudentProfile(response: AxiosResponse): Promise<StudentProfileDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StudentProfileDTO.fromJS(resultData200);
            return Promise.resolve<StudentProfileDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudentProfileDTO>(null as any);
    }

    getStaffDashboard(id: string, cancelToken?: CancelToken): Promise<StaffDashboardDTO> {
        let url_ = this.baseUrl + "/profile/getstaffdashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStaffDashboard(_response);
        });
    }

    protected processGetStaffDashboard(response: AxiosResponse): Promise<StaffDashboardDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StaffDashboardDTO.fromJS(resultData200);
            return Promise.resolve<StaffDashboardDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StaffDashboardDTO>(null as any);
    }

    getStaffProfile(id: string, cancelToken?: CancelToken): Promise<StaffProfileDTO> {
        let url_ = this.baseUrl + "/profile/getstaffprofile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStaffProfile(_response);
        });
    }

    protected processGetStaffProfile(response: AxiosResponse): Promise<StaffProfileDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StaffProfileDTO.fromJS(resultData200);
            return Promise.resolve<StaffProfileDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StaffProfileDTO>(null as any);
    }

    getTeacherDashboard(id: string, cancelToken?: CancelToken): Promise<TeacherDashboardDTO> {
        let url_ = this.baseUrl + "/profile/getteacherdashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeacherDashboard(_response);
        });
    }

    protected processGetTeacherDashboard(response: AxiosResponse): Promise<TeacherDashboardDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeacherDashboardDTO.fromJS(resultData200);
            return Promise.resolve<TeacherDashboardDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeacherDashboardDTO>(null as any);
    }

    getTeacherProfile(id: string, cancelToken?: CancelToken): Promise<TeacherProfileDTO> {
        let url_ = this.baseUrl + "/profile/getteacherprofile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeacherProfile(_response);
        });
    }

    protected processGetTeacherProfile(response: AxiosResponse): Promise<TeacherProfileDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeacherProfileDTO.fromJS(resultData200);
            return Promise.resolve<TeacherProfileDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeacherProfileDTO>(null as any);
    }
}

export interface IReferencialClient {
    getAllCities(): Promise<CityDTO[]>;
    getAllRegions(): Promise<RegionDTO[]>;
    getCitiesByRegion(regionId: string): Promise<CityDTO[]>;
    getRegionById(regionId: string): Promise<RegionDTO>;
    getCityById(cityId: string): Promise<CityDTO>;
    searchCities(nameFragment: string): Promise<CityDTO[]>;
    searchRegions(nameFragment: string): Promise<RegionDTO[]>;
    getAllSchools(): Promise<SchoolMetadataDTO[]>;
    getSchoolById(schoolId: string): Promise<SchoolMetadataDTO>;
    getSchoolByCity(cityId: string): Promise<SchoolMetadataDTO[]>;
    getSchoolsByRegion(regionId: string): Promise<SchoolMetadataDTO[]>;
    searchSchools(nameFragment: string): Promise<SchoolMetadataDTO[]>;
}

export class ReferencialClient implements IReferencialClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getAllCities( cancelToken?: CancelToken): Promise<CityDTO[]> {
        let url_ = this.baseUrl + "/referencial/getallcities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllCities(_response);
        });
    }

    protected processGetAllCities(response: AxiosResponse): Promise<CityDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CityDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO[]>(null as any);
    }

    getAllRegions( cancelToken?: CancelToken): Promise<RegionDTO[]> {
        let url_ = this.baseUrl + "/referencial/getallregions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRegions(_response);
        });
    }

    protected processGetAllRegions(response: AxiosResponse): Promise<RegionDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RegionDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionDTO[]>(null as any);
    }

    getCitiesByRegion(regionId: string, cancelToken?: CancelToken): Promise<CityDTO[]> {
        let url_ = this.baseUrl + "/referencial/getcitiesbyregion/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCitiesByRegion(_response);
        });
    }

    protected processGetCitiesByRegion(response: AxiosResponse): Promise<CityDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CityDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO[]>(null as any);
    }

    getRegionById(regionId: string, cancelToken?: CancelToken): Promise<RegionDTO> {
        let url_ = this.baseUrl + "/referencial/getregionbyid/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRegionById(_response);
        });
    }

    protected processGetRegionById(response: AxiosResponse): Promise<RegionDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegionDTO.fromJS(resultData200);
            return Promise.resolve<RegionDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionDTO>(null as any);
    }

    getCityById(cityId: string, cancelToken?: CancelToken): Promise<CityDTO> {
        let url_ = this.baseUrl + "/referencial/getcitybyid/{cityId}";
        if (cityId === undefined || cityId === null)
            throw new Error("The parameter 'cityId' must be defined.");
        url_ = url_.replace("{cityId}", encodeURIComponent("" + cityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCityById(_response);
        });
    }

    protected processGetCityById(response: AxiosResponse): Promise<CityDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CityDTO.fromJS(resultData200);
            return Promise.resolve<CityDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO>(null as any);
    }

    searchCities(nameFragment: string, cancelToken?: CancelToken): Promise<CityDTO[]> {
        let url_ = this.baseUrl + "/referencial/searchcities/{nameFragment}";
        if (nameFragment === undefined || nameFragment === null)
            throw new Error("The parameter 'nameFragment' must be defined.");
        url_ = url_.replace("{nameFragment}", encodeURIComponent("" + nameFragment));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchCities(_response);
        });
    }

    protected processSearchCities(response: AxiosResponse): Promise<CityDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CityDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDTO[]>(null as any);
    }

    searchRegions(nameFragment: string, cancelToken?: CancelToken): Promise<RegionDTO[]> {
        let url_ = this.baseUrl + "/referencial/searchregions/{nameFragment}";
        if (nameFragment === undefined || nameFragment === null)
            throw new Error("The parameter 'nameFragment' must be defined.");
        url_ = url_.replace("{nameFragment}", encodeURIComponent("" + nameFragment));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchRegions(_response);
        });
    }

    protected processSearchRegions(response: AxiosResponse): Promise<RegionDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RegionDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionDTO[]>(null as any);
    }

    getAllSchools( cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referencial/getallschools";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSchools(_response);
        });
    }

    protected processGetAllSchools(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }

    getSchoolById(schoolId: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO> {
        let url_ = this.baseUrl + "/referencial/getschoolbyid/{schoolId}";
        if (schoolId === undefined || schoolId === null)
            throw new Error("The parameter 'schoolId' must be defined.");
        url_ = url_.replace("{schoolId}", encodeURIComponent("" + schoolId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchoolById(_response);
        });
    }

    protected processGetSchoolById(response: AxiosResponse): Promise<SchoolMetadataDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SchoolMetadataDTO.fromJS(resultData200);
            return Promise.resolve<SchoolMetadataDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO>(null as any);
    }

    getSchoolByCity(cityId: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referencial/getschoolsbycity/{cityId}";
        if (cityId === undefined || cityId === null)
            throw new Error("The parameter 'cityId' must be defined.");
        url_ = url_.replace("{cityId}", encodeURIComponent("" + cityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchoolByCity(_response);
        });
    }

    protected processGetSchoolByCity(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }

    getSchoolsByRegion(regionId: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referencial/getschoolsbyregion/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchoolsByRegion(_response);
        });
    }

    protected processGetSchoolsByRegion(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }

    searchSchools(nameFragment: string, cancelToken?: CancelToken): Promise<SchoolMetadataDTO[]> {
        let url_ = this.baseUrl + "/referencial/searchschools/{nameFragment}";
        if (nameFragment === undefined || nameFragment === null)
            throw new Error("The parameter 'nameFragment' must be defined.");
        url_ = url_.replace("{nameFragment}", encodeURIComponent("" + nameFragment));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchSchools(_response);
        });
    }

    protected processSearchSchools(response: AxiosResponse): Promise<SchoolMetadataDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchoolMetadataDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SchoolMetadataDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchoolMetadataDTO[]>(null as any);
    }
}

export interface IResourcesClient {
    createSupply(dto: SchoolSupplyDTO): Promise<boolean>;
    getPaginatedSupplies(searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfSchoolSupplyDTO>;
    updateSupply(id: string, dto: SchoolSupplyDTO): Promise<boolean>;
    createBook(dto: BookDTO): Promise<boolean>;
    updateBook(id: string, dto: BookDTO): Promise<boolean>;
    assignToGrade(dto: GradeResourceDTO): Promise<boolean>;
    getPaginatedResources(gradeLevelId: string | null | undefined, resourceType: ResourceType | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfGradeResourceDTO>;
    get(): Promise<{ [key: string]: { [key: string]: string; }; }>;
}

export class ResourcesClient implements IResourcesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    createSupply(dto: SchoolSupplyDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/resources/supplies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSupply(_response);
        });
    }

    protected processCreateSupply(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginatedSupplies(searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfSchoolSupplyDTO> {
        let url_ = this.baseUrl + "/resources/supplies?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedSupplies(_response);
        });
    }

    protected processGetPaginatedSupplies(response: AxiosResponse): Promise<PagedResultOfSchoolSupplyDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfSchoolSupplyDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfSchoolSupplyDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfSchoolSupplyDTO>(null as any);
    }

    updateSupply(id: string, dto: SchoolSupplyDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/resources/supplies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSupply(_response);
        });
    }

    protected processUpdateSupply(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    createBook(dto: BookDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/resources/books";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateBook(_response);
        });
    }

    protected processCreateBook(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    updateBook(id: string, dto: BookDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/resources/books/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateBook(_response);
        });
    }

    protected processUpdateBook(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    assignToGrade(dto: GradeResourceDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/resources/assign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignToGrade(_response);
        });
    }

    protected processAssignToGrade(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginatedResources(gradeLevelId: string | null | undefined, resourceType: ResourceType | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfGradeResourceDTO> {
        let url_ = this.baseUrl + "/resources/getresourcesbycriteria?";
        if (gradeLevelId !== undefined && gradeLevelId !== null)
            url_ += "GradeLevelId=" + encodeURIComponent("" + gradeLevelId) + "&";
        if (resourceType !== undefined && resourceType !== null)
            url_ += "ResourceType=" + encodeURIComponent("" + resourceType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedResources(_response);
        });
    }

    protected processGetPaginatedResources(response: AxiosResponse): Promise<PagedResultOfGradeResourceDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfGradeResourceDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfGradeResourceDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfGradeResourceDTO>(null as any);
    }

    get( cancelToken?: CancelToken): Promise<{ [key: string]: { [key: string]: string; }; }> {
        let url_ = this.baseUrl + "/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<{ [key: string]: { [key: string]: string; }; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : {};
                }
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<{ [key: string]: { [key: string]: string; }; }>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: { [key: string]: string; }; }>(null as any);
    }
}

export interface ISchedulesClient {
    create(dto: ScheduleDTO): Promise<boolean>;
    update(id: string, dto: ScheduleDTO): Promise<boolean>;
    delete(id: string): Promise<boolean>;
    getByGradeSection(gradeSectionId: string): Promise<ScheduleDTO[]>;
    getTeacherSchedule(teacherId: string): Promise<ScheduleDTO[]>;
    autoGenerate(constraints: ScheduleConstraintsDTO): Promise<ScheduleDTO[]>;
    checkConflict(dto: ScheduleConflictCheckDTO): Promise<boolean>;
}

export class SchedulesClient implements ISchedulesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(dto: ScheduleDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/schedules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    update(id: string, dto: ScheduleDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/schedules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    delete(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/schedules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getByGradeSection(gradeSectionId: string, cancelToken?: CancelToken): Promise<ScheduleDTO[]> {
        let url_ = this.baseUrl + "/schedules/gradesection/{gradeSectionId}";
        if (gradeSectionId === undefined || gradeSectionId === null)
            throw new Error("The parameter 'gradeSectionId' must be defined.");
        url_ = url_.replace("{gradeSectionId}", encodeURIComponent("" + gradeSectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByGradeSection(_response);
        });
    }

    protected processGetByGradeSection(response: AxiosResponse): Promise<ScheduleDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScheduleDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ScheduleDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduleDTO[]>(null as any);
    }

    getTeacherSchedule(teacherId: string, cancelToken?: CancelToken): Promise<ScheduleDTO[]> {
        let url_ = this.baseUrl + "/schedules/teacher/{teacherId}";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined.");
        url_ = url_.replace("{teacherId}", encodeURIComponent("" + teacherId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeacherSchedule(_response);
        });
    }

    protected processGetTeacherSchedule(response: AxiosResponse): Promise<ScheduleDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScheduleDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ScheduleDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduleDTO[]>(null as any);
    }

    autoGenerate(constraints: ScheduleConstraintsDTO, cancelToken?: CancelToken): Promise<ScheduleDTO[]> {
        let url_ = this.baseUrl + "/schedules/generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(constraints);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAutoGenerate(_response);
        });
    }

    protected processAutoGenerate(response: AxiosResponse): Promise<ScheduleDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScheduleDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ScheduleDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScheduleDTO[]>(null as any);
    }

    checkConflict(dto: ScheduleConflictCheckDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/schedules/checkconflict";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckConflict(_response);
        });
    }

    protected processCheckConflict(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface ISchoolClient {
    get(schoolId: string): Promise<BranchDto[]>;
}

export class SchoolClient implements ISchoolClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get(schoolId: string, cancelToken?: CancelToken): Promise<BranchDto[]> {
        let url_ = this.baseUrl + "/school/getschoolbranches/{schoolId}";
        if (schoolId === undefined || schoolId === null)
            throw new Error("The parameter 'schoolId' must be defined.");
        url_ = url_.replace("{schoolId}", encodeURIComponent("" + schoolId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<BranchDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BranchDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BranchDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BranchDto[]>(null as any);
    }
}

export interface IStaffClient {
    create(dto: CreateStaffDTO): Promise<CreateUserRequestDto>;
    getPaginated(branchId: string | null | undefined, searchTerm: string | undefined, role: StaffRole | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfStaffDTO>;
    bulkCreate(dto: BulkStaffDTO): Promise<boolean>;
    getById(id: string): Promise<StaffDTO>;
    getByUserId(id: string): Promise<StaffDTO>;
    assignRole(id: string, dto: StaffRoleDTO): Promise<boolean>;
    getAuditLogs(id: string): Promise<StaffAuditDTO[]>;
}

export class StaffClient implements IStaffClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(dto: CreateStaffDTO, cancelToken?: CancelToken): Promise<CreateUserRequestDto> {
        let url_ = this.baseUrl + "/staff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<CreateUserRequestDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateUserRequestDto.fromJS(resultData200);
            return Promise.resolve<CreateUserRequestDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateUserRequestDto>(null as any);
    }

    getPaginated(branchId: string | null | undefined, searchTerm: string | undefined, role: StaffRole | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfStaffDTO> {
        let url_ = this.baseUrl + "/staff?";
        if (branchId !== undefined && branchId !== null)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfStaffDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfStaffDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfStaffDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfStaffDTO>(null as any);
    }

    bulkCreate(dto: BulkStaffDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/staff/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkCreate(_response);
        });
    }

    protected processBulkCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getById(id: string, cancelToken?: CancelToken): Promise<StaffDTO> {
        let url_ = this.baseUrl + "/staff/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<StaffDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StaffDTO.fromJS(resultData200);
            return Promise.resolve<StaffDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StaffDTO>(null as any);
    }

    getByUserId(id: string, cancelToken?: CancelToken): Promise<StaffDTO> {
        let url_ = this.baseUrl + "/staff/byuserid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByUserId(_response);
        });
    }

    protected processGetByUserId(response: AxiosResponse): Promise<StaffDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StaffDTO.fromJS(resultData200);
            return Promise.resolve<StaffDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StaffDTO>(null as any);
    }

    assignRole(id: string, dto: StaffRoleDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/staff/{id}/role";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignRole(_response);
        });
    }

    protected processAssignRole(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAuditLogs(id: string, cancelToken?: CancelToken): Promise<StaffAuditDTO[]> {
        let url_ = this.baseUrl + "/staff/audit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAuditLogs(_response);
        });
    }

    protected processGetAuditLogs(response: AxiosResponse): Promise<StaffAuditDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaffAuditDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StaffAuditDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StaffAuditDTO[]>(null as any);
    }
}

export interface IStudentsClient {
    create(dto: CreateStudentDTO): Promise<CreateStudentUserDTO>;
    getPaginated(branchId: string | null | undefined, status: string | undefined, enrollmentStart: Date | null | undefined, enrollmentEnd: Date | null | undefined, searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfStudentDTO>;
    update(id: string, dto: StudentDTO): Promise<boolean>;
    transitionStatus(id: string, dto: StudentStatusTransitionDTO): Promise<boolean>;
    getWithDetails(id: string): Promise<StudentDetailDTO>;
    getByUserId(id: string): Promise<StudentDTO>;
    getParents(id: string): Promise<PagedResultOfStudentParentDTO>;
}

export class StudentsClient implements IStudentsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(dto: CreateStudentDTO, cancelToken?: CancelToken): Promise<CreateStudentUserDTO> {
        let url_ = this.baseUrl + "/students";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<CreateStudentUserDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateStudentUserDTO.fromJS(resultData200);
            return Promise.resolve<CreateStudentUserDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateStudentUserDTO>(null as any);
    }

    getPaginated(branchId: string | null | undefined, status: string | undefined, enrollmentStart: Date | null | undefined, enrollmentEnd: Date | null | undefined, searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfStudentDTO> {
        let url_ = this.baseUrl + "/students?";
        if (branchId !== undefined && branchId !== null)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (enrollmentStart !== undefined && enrollmentStart !== null)
            url_ += "EnrollmentStart=" + encodeURIComponent(enrollmentStart ? "" + enrollmentStart.toISOString() : "") + "&";
        if (enrollmentEnd !== undefined && enrollmentEnd !== null)
            url_ += "EnrollmentEnd=" + encodeURIComponent(enrollmentEnd ? "" + enrollmentEnd.toISOString() : "") + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfStudentDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfStudentDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfStudentDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfStudentDTO>(null as any);
    }

    update(id: string, dto: StudentDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/students/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    transitionStatus(id: string, dto: StudentStatusTransitionDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/students/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTransitionStatus(_response);
        });
    }

    protected processTransitionStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getWithDetails(id: string, cancelToken?: CancelToken): Promise<StudentDetailDTO> {
        let url_ = this.baseUrl + "/students/{id}/details";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWithDetails(_response);
        });
    }

    protected processGetWithDetails(response: AxiosResponse): Promise<StudentDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StudentDetailDTO.fromJS(resultData200);
            return Promise.resolve<StudentDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudentDetailDTO>(null as any);
    }

    getByUserId(id: string, cancelToken?: CancelToken): Promise<StudentDTO> {
        let url_ = this.baseUrl + "/students/byuserid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByUserId(_response);
        });
    }

    protected processGetByUserId(response: AxiosResponse): Promise<StudentDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StudentDTO.fromJS(resultData200);
            return Promise.resolve<StudentDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudentDTO>(null as any);
    }

    getParents(id: string, cancelToken?: CancelToken): Promise<PagedResultOfStudentParentDTO> {
        let url_ = this.baseUrl + "/students/{id}/parents";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetParents(_response);
        });
    }

    protected processGetParents(response: AxiosResponse): Promise<PagedResultOfStudentParentDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfStudentParentDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfStudentParentDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfStudentParentDTO>(null as any);
    }
}

export interface ITeachersClient {
    create(dto: CreateTeacherDTO): Promise<CreateUserRequestDto>;
    getPaginated(branchId: string | null | undefined, specialization: string | null | undefined, status: TeacherStatusEnum | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, sortBy: string | null | undefined, isAscending: boolean | undefined): Promise<PagedResultOfTeacherDTO>;
    update(id: string, dto: TeacherDTO): Promise<boolean>;
    getById(id: string): Promise<TeacherDTO>;
    updateEmploymentStatus(id: string, newStatus: string): Promise<boolean>;
    getAssignedCourses(id: string): Promise<CourseScheduleDTO[]>;
    getByUserId(id: string): Promise<TeacherDTO>;
}

export class TeachersClient implements ITeachersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(dto: CreateTeacherDTO, cancelToken?: CancelToken): Promise<CreateUserRequestDto> {
        let url_ = this.baseUrl + "/teachers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<CreateUserRequestDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateUserRequestDto.fromJS(resultData200);
            return Promise.resolve<CreateUserRequestDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateUserRequestDto>(null as any);
    }

    getPaginated(branchId: string | null | undefined, specialization: string | null | undefined, status: TeacherStatusEnum | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined, sortBy: string | null | undefined, isAscending: boolean | undefined, cancelToken?: CancelToken): Promise<PagedResultOfTeacherDTO> {
        let url_ = this.baseUrl + "/teachers?";
        if (branchId !== undefined && branchId !== null)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (specialization !== undefined && specialization !== null)
            url_ += "Specialization=" + encodeURIComponent("" + specialization) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (isAscending === null)
            throw new Error("The parameter 'isAscending' cannot be null.");
        else if (isAscending !== undefined)
            url_ += "IsAscending=" + encodeURIComponent("" + isAscending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfTeacherDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfTeacherDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfTeacherDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfTeacherDTO>(null as any);
    }

    update(id: string, dto: TeacherDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/teachers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getById(id: string, cancelToken?: CancelToken): Promise<TeacherDTO> {
        let url_ = this.baseUrl + "/teachers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<TeacherDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeacherDTO.fromJS(resultData200);
            return Promise.resolve<TeacherDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeacherDTO>(null as any);
    }

    updateEmploymentStatus(id: string, newStatus: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/teachers/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newStatus);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEmploymentStatus(_response);
        });
    }

    protected processUpdateEmploymentStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAssignedCourses(id: string, cancelToken?: CancelToken): Promise<CourseScheduleDTO[]> {
        let url_ = this.baseUrl + "/teachers/{id}/courses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAssignedCourses(_response);
        });
    }

    protected processGetAssignedCourses(response: AxiosResponse): Promise<CourseScheduleDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseScheduleDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CourseScheduleDTO[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseScheduleDTO[]>(null as any);
    }

    getByUserId(id: string, cancelToken?: CancelToken): Promise<TeacherDTO> {
        let url_ = this.baseUrl + "/teachers/byuserid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByUserId(_response);
        });
    }

    protected processGetByUserId(response: AxiosResponse): Promise<TeacherDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeacherDTO.fromJS(resultData200);
            return Promise.resolve<TeacherDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeacherDTO>(null as any);
    }
}

export interface ITransferClient {
    submitRequest(dto: TransferRequestDTO): Promise<boolean>;
    getPaginated(studentId: string | null | undefined, fromSchoolId: string | null | undefined, status: TransferRequestStatus | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfTransferRequestDTO>;
    updateStatus(id: string, dto: TransferStatusUpdateDTO): Promise<boolean>;
    getDetails(id: string): Promise<TransferRequestDetailDTO>;
    updateRequest(id: string, dto: TransferRequestUpdateDTO): Promise<boolean>;
    cancelRequest(id: string): Promise<boolean>;
    checkEligibility(studentId: string): Promise<TransferEligibilityResultDTO>;
    getHistory(transferRequestId: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PagedResultOfTransferRequestHistoryDTO>;
}

export class TransferClient implements ITransferClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    submitRequest(dto: TransferRequestDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/transfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubmitRequest(_response);
        });
    }

    protected processSubmitRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPaginated(studentId: string | null | undefined, fromSchoolId: string | null | undefined, status: TransferRequestStatus | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfTransferRequestDTO> {
        let url_ = this.baseUrl + "/transfer?";
        if (studentId !== undefined && studentId !== null)
            url_ += "StudentId=" + encodeURIComponent("" + studentId) + "&";
        if (fromSchoolId !== undefined && fromSchoolId !== null)
            url_ += "FromSchoolId=" + encodeURIComponent("" + fromSchoolId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginated(_response);
        });
    }

    protected processGetPaginated(response: AxiosResponse): Promise<PagedResultOfTransferRequestDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfTransferRequestDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfTransferRequestDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfTransferRequestDTO>(null as any);
    }

    updateStatus(id: string, dto: TransferStatusUpdateDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/transfer/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getDetails(id: string, cancelToken?: CancelToken): Promise<TransferRequestDetailDTO> {
        let url_ = this.baseUrl + "/transfer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDetails(_response);
        });
    }

    protected processGetDetails(response: AxiosResponse): Promise<TransferRequestDetailDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransferRequestDetailDTO.fromJS(resultData200);
            return Promise.resolve<TransferRequestDetailDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferRequestDetailDTO>(null as any);
    }

    updateRequest(id: string, dto: TransferRequestUpdateDTO, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/transfer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRequest(_response);
        });
    }

    protected processUpdateRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    cancelRequest(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/transfer/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelRequest(_response);
        });
    }

    protected processCancelRequest(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    checkEligibility(studentId: string, cancelToken?: CancelToken): Promise<TransferEligibilityResultDTO> {
        let url_ = this.baseUrl + "/transfer/eligibility/{studentId}";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined.");
        url_ = url_.replace("{studentId}", encodeURIComponent("" + studentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckEligibility(_response);
        });
    }

    protected processCheckEligibility(response: AxiosResponse): Promise<TransferEligibilityResultDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TransferEligibilityResultDTO.fromJS(resultData200);
            return Promise.resolve<TransferEligibilityResultDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferEligibilityResultDTO>(null as any);
    }

    getHistory(transferRequestId: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<PagedResultOfTransferRequestHistoryDTO> {
        let url_ = this.baseUrl + "/transfer/history?";
        if (transferRequestId === null)
            throw new Error("The parameter 'transferRequestId' cannot be null.");
        else if (transferRequestId !== undefined)
            url_ += "TransferRequestId=" + encodeURIComponent("" + transferRequestId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: AxiosResponse): Promise<PagedResultOfTransferRequestHistoryDTO> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfTransferRequestHistoryDTO.fromJS(resultData200);
            return Promise.resolve<PagedResultOfTransferRequestHistoryDTO>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfTransferRequestHistoryDTO>(null as any);
    }
}

export interface IAppLifetimeClient {
    reload(): Promise<FileResponse>;
}

export class AppLifetimeClient implements IAppLifetimeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    reload( cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/reload";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReload(_response);
        });
    }

    protected processReload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AcademicYearDTO implements IAcademicYearDTO {
    startYear?: number;
    endYear?: number;
    description?: string;

    constructor(data?: IAcademicYearDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AcademicYearDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicYearDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["description"] = this.description;
        return data;
    }
}

export interface IAcademicYearDTO {
    startYear?: number;
    endYear?: number;
    description?: string;
}

export abstract class PagedResultBase implements IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;

    constructor(data?: IPagedResultBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
        }
    }

    static fromJS(data: any): PagedResultBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PagedResultBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        return data;
    }
}

export interface IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
}

export class PagedResultOfSemesterDTO extends PagedResultBase implements IPagedResultOfSemesterDTO {
    results?: SemesterDTO[];

    constructor(data?: IPagedResultOfSemesterDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SemesterDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfSemesterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfSemesterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfSemesterDTO extends IPagedResultBase {
    results?: SemesterDTO[];
}

export class SemesterDTO implements ISemesterDTO {
    id?: string;
    academicYear?: AcademicYearDTO;
    name?: SemesterNameEnum;
    startDate?: Date;
    endDate?: Date;

    constructor(data?: ISemesterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.academicYear = _data["academicYear"] ? AcademicYearDTO.fromJS(_data["academicYear"]) : <any>undefined;
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SemesterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SemesterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["academicYear"] = this.academicYear ? this.academicYear.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISemesterDTO {
    id?: string;
    academicYear?: AcademicYearDTO;
    name?: SemesterNameEnum;
    startDate?: Date;
    endDate?: Date;
}

export enum SemesterNameEnum {
    Fall = "Fall",
    Spring = "Spring",
}

export class FilterSemesterDTO implements IFilterSemesterDTO {
    pageNumber?: number;
    pageSize?: number;
    sortBy?: string;
    isAscending?: boolean;

    constructor(data?: IFilterSemesterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.sortBy = _data["sortBy"];
            this.isAscending = _data["isAscending"];
        }
    }

    static fromJS(data: any): FilterSemesterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FilterSemesterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["sortBy"] = this.sortBy;
        data["isAscending"] = this.isAscending;
        return data;
    }
}

export interface IFilterSemesterDTO {
    pageNumber?: number;
    pageSize?: number;
    sortBy?: string;
    isAscending?: boolean;
}

export class AttendanceDTO implements IAttendanceDTO {
    studentId?: string;
    courseId?: string;
    date?: Date;
    status?: AttendanceEnum;
    notesFr?: string | undefined;
    notesAr?: string | undefined;
    notesEn?: string | undefined;

    constructor(data?: IAttendanceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.courseId = _data["courseId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.notesFr = _data["notesFr"];
            this.notesAr = _data["notesAr"];
            this.notesEn = _data["notesEn"];
        }
    }

    static fromJS(data: any): AttendanceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["courseId"] = this.courseId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["notesFr"] = this.notesFr;
        data["notesAr"] = this.notesAr;
        data["notesEn"] = this.notesEn;
        return data;
    }
}

export interface IAttendanceDTO {
    studentId?: string;
    courseId?: string;
    date?: Date;
    status?: AttendanceEnum;
    notesFr?: string | undefined;
    notesAr?: string | undefined;
    notesEn?: string | undefined;
}

export enum AttendanceEnum {
    Present = "Present",
    Late = "Late",
    Absent = "Absent",
}

export class PagedResultOfAttendanceDTO extends PagedResultBase implements IPagedResultOfAttendanceDTO {
    results?: AttendanceDTO[];

    constructor(data?: IPagedResultOfAttendanceDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AttendanceDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfAttendanceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAttendanceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfAttendanceDTO extends IPagedResultBase {
    results?: AttendanceDTO[];
}

export enum AttendanceChangeReasonEnum {
    AbscenseJustified = "AbscenseJustified",
    RecordMistake = "RecordMistake",
    NewRecord = "NewRecord",
}

export class AttendanceSummaryDTO implements IAttendanceSummaryDTO {
    totalDays?: number;
    presentDays?: number;
    lateDays?: number;
    absentDays?: number;
    attendanceRate?: number;

    constructor(data?: IAttendanceSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalDays = _data["totalDays"];
            this.presentDays = _data["presentDays"];
            this.lateDays = _data["lateDays"];
            this.absentDays = _data["absentDays"];
            this.attendanceRate = _data["attendanceRate"];
        }
    }

    static fromJS(data: any): AttendanceSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalDays"] = this.totalDays;
        data["presentDays"] = this.presentDays;
        data["lateDays"] = this.lateDays;
        data["absentDays"] = this.absentDays;
        data["attendanceRate"] = this.attendanceRate;
        return data;
    }
}

export interface IAttendanceSummaryDTO {
    totalDays?: number;
    presentDays?: number;
    lateDays?: number;
    absentDays?: number;
    attendanceRate?: number;
}

export class CourseDTO implements ICourseDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleFr = _data["titleFr"];
            this.titleAr = _data["titleAr"];
            this.titleEn = _data["titleEn"];
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleFr"] = this.titleFr;
        data["titleAr"] = this.titleAr;
        data["titleEn"] = this.titleEn;
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface ICourseDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;
}

export class PagedResultOfCourseDTO extends PagedResultBase implements IPagedResultOfCourseDTO {
    results?: CourseDTO[];

    constructor(data?: IPagedResultOfCourseDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CourseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfCourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfCourseDTO extends IPagedResultBase {
    results?: CourseDTO[];
}

export class EnrollmentDTO implements IEnrollmentDTO {
    studentId?: string;
    branchId?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    adminComment?: string | undefined;

    constructor(data?: IEnrollmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.branchId = _data["branchId"];
            this.status = _data["status"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            this.adminComment = _data["adminComment"];
        }
    }

    static fromJS(data: any): EnrollmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["branchId"] = this.branchId;
        data["status"] = this.status;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["adminComment"] = this.adminComment;
        return data;
    }
}

export interface IEnrollmentDTO {
    studentId?: string;
    branchId?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    adminComment?: string | undefined;
}

export enum EnrollmentStatusEnum {
    None = "None",
    Pending = "Pending",
    UnderReview = "UnderReview",
    Approved = "Approved",
    Rejected = "Rejected",
    Completed = "Completed",
}

export class EnrollmentDetailDTO extends EnrollmentDTO implements IEnrollmentDetailDTO {
    studentName?: string;
    branchName?: string;
    documents?: DocumentDTO[];

    constructor(data?: IEnrollmentDetailDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.studentName = _data["studentName"];
            this.branchName = _data["branchName"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnrollmentDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["branchName"] = this.branchName;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEnrollmentDetailDTO extends IEnrollmentDTO {
    studentName?: string;
    branchName?: string;
    documents?: DocumentDTO[];
}

export class DocumentDTO implements IDocumentDTO {
    documentType?: DocumentTypeEnum;
    filePath?: string;
    uploadedAt?: Date;
    verificationStatus?: VerificationStatusEnum;

    constructor(data?: IDocumentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.filePath = _data["filePath"];
            this.uploadedAt = _data["uploadedAt"] ? new Date(_data["uploadedAt"].toString()) : <any>undefined;
            this.verificationStatus = _data["verificationStatus"];
        }
    }

    static fromJS(data: any): DocumentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["filePath"] = this.filePath;
        data["uploadedAt"] = this.uploadedAt ? this.uploadedAt.toISOString() : <any>undefined;
        data["verificationStatus"] = this.verificationStatus;
        return data;
    }
}

export interface IDocumentDTO {
    documentType?: DocumentTypeEnum;
    filePath?: string;
    uploadedAt?: Date;
    verificationStatus?: VerificationStatusEnum;
}

export enum DocumentTypeEnum {
    Unspecified = "Unspecified",
    UserAvatar = "UserAvatar",
    CNI = "CNI",
    CNIFront = "CNIFront",
    CNIBack = "CNIBack",
    CNIFatherFront = "CNIFatherFront",
    CNIFatherBack = "CNIFatherBack",
    CNIMotherFront = "CNIMotherFront",
    CNIMotherBack = "CNIMotherBack",
    ProofOfAddress = "ProofOfAddress",
    Extrait = "Extrait",
    Picture = "Picture",
}

export enum VerificationStatusEnum {
    Pending = "Pending",
    Verified = "Verified",
    Rejected = "Rejected",
}

export class PagedResultOfEnrollmentDTO extends PagedResultBase implements IPagedResultOfEnrollmentDTO {
    results?: EnrollmentDTO[];

    constructor(data?: IPagedResultOfEnrollmentDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(EnrollmentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfEnrollmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfEnrollmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfEnrollmentDTO extends IPagedResultBase {
    results?: EnrollmentDTO[];
}

export class EnrollmentStatusUpdateDTO implements IEnrollmentStatusUpdateDTO {
    newStatus?: EnrollmentStatusEnum;
    adminComment?: string | undefined;
    changeReason?: EnrollmentChangeReasonEnum;

    constructor(data?: IEnrollmentStatusUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newStatus = _data["newStatus"];
            this.adminComment = _data["adminComment"];
            this.changeReason = _data["changeReason"];
        }
    }

    static fromJS(data: any): EnrollmentStatusUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentStatusUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newStatus"] = this.newStatus;
        data["adminComment"] = this.adminComment;
        data["changeReason"] = this.changeReason;
        return data;
    }
}

export interface IEnrollmentStatusUpdateDTO {
    newStatus?: EnrollmentStatusEnum;
    adminComment?: string | undefined;
    changeReason?: EnrollmentChangeReasonEnum;
}

export enum EnrollmentChangeReasonEnum {
    NewRecord = "NewRecord",
    StatusUpdate = "StatusUpdate",
    Correction = "Correction",
    WorkflowTransition = "WorkflowTransition",
    DocumentVerification = "DocumentVerification",
}

export class CreateEnrollmentRequestDTO implements ICreateEnrollmentRequestDTO {
    studentId?: string;
    branchId?: string;
    isDraft?: boolean;
    documents?: EnrollmentDocumentUploadDTO[];

    constructor(data?: ICreateEnrollmentRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.branchId = _data["branchId"];
            this.isDraft = _data["isDraft"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(EnrollmentDocumentUploadDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEnrollmentRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEnrollmentRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["branchId"] = this.branchId;
        data["isDraft"] = this.isDraft;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateEnrollmentRequestDTO {
    studentId?: string;
    branchId?: string;
    isDraft?: boolean;
    documents?: EnrollmentDocumentUploadDTO[];
}

export class EnrollmentDocumentUploadDTO implements IEnrollmentDocumentUploadDTO {
    enrollmentId?: string;
    documentType?: DocumentTypeEnum;
    fileName?: string;
    contentType?: string;
    fileContent?: string;

    constructor(data?: IEnrollmentDocumentUploadDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.documentType = _data["documentType"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.fileContent = _data["fileContent"];
        }
    }

    static fromJS(data: any): EnrollmentDocumentUploadDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentDocumentUploadDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["documentType"] = this.documentType;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["fileContent"] = this.fileContent;
        return data;
    }
}

export interface IEnrollmentDocumentUploadDTO {
    enrollmentId?: string;
    documentType?: DocumentTypeEnum;
    fileName?: string;
    contentType?: string;
    fileContent?: string;
}

export class PagedResultOfEnrollmentRequestDTO extends PagedResultBase implements IPagedResultOfEnrollmentRequestDTO {
    results?: EnrollmentRequestDTO[];

    constructor(data?: IPagedResultOfEnrollmentRequestDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(EnrollmentRequestDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfEnrollmentRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfEnrollmentRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfEnrollmentRequestDTO extends IPagedResultBase {
    results?: EnrollmentRequestDTO[];
}

export class EnrollmentRequestDTO implements IEnrollmentRequestDTO {
    id?: string;
    studentId?: string;
    requestCode?: string;
    schoolId?: string;
    branchId?: string;
    schoolName?: string;
    requestedByUserId?: string;
    requestedByName?: string;
    status?: EnrollmentRequestStatusEnum;
    createdAt?: Date;
    submittedAt?: Date | undefined;

    constructor(data?: IEnrollmentRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.requestCode = _data["requestCode"];
            this.schoolId = _data["schoolId"];
            this.branchId = _data["branchId"];
            this.schoolName = _data["schoolName"];
            this.requestedByUserId = _data["requestedByUserId"];
            this.requestedByName = _data["requestedByName"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EnrollmentRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["requestCode"] = this.requestCode;
        data["schoolId"] = this.schoolId;
        data["branchId"] = this.branchId;
        data["schoolName"] = this.schoolName;
        data["requestedByUserId"] = this.requestedByUserId;
        data["requestedByName"] = this.requestedByName;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEnrollmentRequestDTO {
    id?: string;
    studentId?: string;
    requestCode?: string;
    schoolId?: string;
    branchId?: string;
    schoolName?: string;
    requestedByUserId?: string;
    requestedByName?: string;
    status?: EnrollmentRequestStatusEnum;
    createdAt?: Date;
    submittedAt?: Date | undefined;
}

export enum EnrollmentRequestStatusEnum {
    Draft = "Draft",
    Submitted = "Submitted",
    Approved = "Approved",
    Rejected = "Rejected",
}

export class EnrollmentRequestDetailDTO implements IEnrollmentRequestDetailDTO {
    id?: string;
    requestCode?: string;
    schoolId?: string;
    schoolName?: string;
    student?: StudentDTO;
    parent?: ParentDTO;
    documents?: DocumentDTO[];
    status?: EnrollmentRequestStatusEnum;
    createdAt?: Date;
    submittedAt?: Date | undefined;

    constructor(data?: IEnrollmentRequestDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestCode = _data["requestCode"];
            this.schoolId = _data["schoolId"];
            this.schoolName = _data["schoolName"];
            this.student = _data["student"] ? StudentDTO.fromJS(_data["student"]) : <any>undefined;
            this.parent = _data["parent"] ? ParentDTO.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EnrollmentRequestDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentRequestDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestCode"] = this.requestCode;
        data["schoolId"] = this.schoolId;
        data["schoolName"] = this.schoolName;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEnrollmentRequestDetailDTO {
    id?: string;
    requestCode?: string;
    schoolId?: string;
    schoolName?: string;
    student?: StudentDTO;
    parent?: ParentDTO;
    documents?: DocumentDTO[];
    status?: EnrollmentRequestStatusEnum;
    createdAt?: Date;
    submittedAt?: Date | undefined;
}

export class StudentDTO implements IStudentDTO {
    id?: string | undefined;
    userId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    dateOfBirth?: Date;
    gender?: GenderEnum;
    status?: string;

    constructor(data?: IStudentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): StudentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["status"] = this.status;
        return data;
    }
}

export interface IStudentDTO {
    id?: string | undefined;
    userId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    dateOfBirth?: Date;
    gender?: GenderEnum;
    status?: string;
}

export enum GenderEnum {
    Other = "Other",
    Male = "Male",
    Female = "Female",
}

export class ParentDTO implements IParentDTO {
    id?: string;
    userId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string;
    phone?: string;
    cin?: string;
    occupation?: string;
    addressFr?: string;
    addressAr?: string;
    isIdentityVerified?: boolean;
    verificationDate?: Date | undefined;

    constructor(data?: IParentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.cin = _data["cin"];
            this.occupation = _data["occupation"];
            this.addressFr = _data["addressFr"];
            this.addressAr = _data["addressAr"];
            this.isIdentityVerified = _data["isIdentityVerified"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ParentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["cin"] = this.cin;
        data["occupation"] = this.occupation;
        data["addressFr"] = this.addressFr;
        data["addressAr"] = this.addressAr;
        data["isIdentityVerified"] = this.isIdentityVerified;
        data["verificationDate"] = this.verificationDate ? this.verificationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParentDTO {
    id?: string;
    userId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string;
    phone?: string;
    cin?: string;
    occupation?: string;
    addressFr?: string;
    addressAr?: string;
    isIdentityVerified?: boolean;
    verificationDate?: Date | undefined;
}

export class UpdateEnrollmentRequestDTO implements IUpdateEnrollmentRequestDTO {
    branchId?: string;
    studentId?: string;

    constructor(data?: IUpdateEnrollmentRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"];
            this.studentId = _data["studentId"];
        }
    }

    static fromJS(data: any): UpdateEnrollmentRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEnrollmentRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["studentId"] = this.studentId;
        return data;
    }
}

export interface IUpdateEnrollmentRequestDTO {
    branchId?: string;
    studentId?: string;
}

export class EnrollmentMetricsDTO implements IEnrollmentMetricsDTO {
    totalEnrollments?: number;
    pending?: number;
    approved?: number;
    rejected?: number;
    completed?: number;

    constructor(data?: IEnrollmentMetricsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalEnrollments = _data["totalEnrollments"];
            this.pending = _data["pending"];
            this.approved = _data["approved"];
            this.rejected = _data["rejected"];
            this.completed = _data["completed"];
        }
    }

    static fromJS(data: any): EnrollmentMetricsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentMetricsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalEnrollments"] = this.totalEnrollments;
        data["pending"] = this.pending;
        data["approved"] = this.approved;
        data["rejected"] = this.rejected;
        data["completed"] = this.completed;
        return data;
    }
}

export interface IEnrollmentMetricsDTO {
    totalEnrollments?: number;
    pending?: number;
    approved?: number;
    rejected?: number;
    completed?: number;
}

export class DateRangeDTO implements IDateRangeDTO {
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IDateRangeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDateRangeDTO {
    startDate?: Date;
    endDate?: Date;
}

export class AttendanceExcuseDTO implements IAttendanceExcuseDTO {
    attendanceId?: string;
    explanation?: string;
    language?: string;
    documentUrl?: string | undefined;
    submittedBy?: string;

    constructor(data?: IAttendanceExcuseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attendanceId = _data["attendanceId"];
            this.explanation = _data["explanation"];
            this.language = _data["language"];
            this.documentUrl = _data["documentUrl"];
            this.submittedBy = _data["submittedBy"];
        }
    }

    static fromJS(data: any): AttendanceExcuseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceExcuseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attendanceId"] = this.attendanceId;
        data["explanation"] = this.explanation;
        data["language"] = this.language;
        data["documentUrl"] = this.documentUrl;
        data["submittedBy"] = this.submittedBy;
        return data;
    }
}

export interface IAttendanceExcuseDTO {
    attendanceId?: string;
    explanation?: string;
    language?: string;
    documentUrl?: string | undefined;
    submittedBy?: string;
}

export class CourseDetailDTO implements ICourseDetailDTO {
    titleFr?: string;
    titleAr?: string;
    titleEn?: string;
    code?: string;
    description?: string;
    teacherAssignments?: TeacherAssignmentDetailDTO[];
    gradeMappings?: CourseGradeMappingDTO[];
    materials?: CourseMaterialDTO[] | undefined;

    constructor(data?: ICourseDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleFr = _data["titleFr"];
            this.titleAr = _data["titleAr"];
            this.titleEn = _data["titleEn"];
            this.code = _data["code"];
            this.description = _data["description"];
            if (Array.isArray(_data["teacherAssignments"])) {
                this.teacherAssignments = [] as any;
                for (let item of _data["teacherAssignments"])
                    this.teacherAssignments!.push(TeacherAssignmentDetailDTO.fromJS(item));
            }
            if (Array.isArray(_data["gradeMappings"])) {
                this.gradeMappings = [] as any;
                for (let item of _data["gradeMappings"])
                    this.gradeMappings!.push(CourseGradeMappingDTO.fromJS(item));
            }
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(CourseMaterialDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleFr"] = this.titleFr;
        data["titleAr"] = this.titleAr;
        data["titleEn"] = this.titleEn;
        data["code"] = this.code;
        data["description"] = this.description;
        if (Array.isArray(this.teacherAssignments)) {
            data["teacherAssignments"] = [];
            for (let item of this.teacherAssignments)
                data["teacherAssignments"].push(item.toJSON());
        }
        if (Array.isArray(this.gradeMappings)) {
            data["gradeMappings"] = [];
            for (let item of this.gradeMappings)
                data["gradeMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseDetailDTO {
    titleFr?: string;
    titleAr?: string;
    titleEn?: string;
    code?: string;
    description?: string;
    teacherAssignments?: TeacherAssignmentDetailDTO[];
    gradeMappings?: CourseGradeMappingDTO[];
    materials?: CourseMaterialDTO[] | undefined;
}

export class TeacherAssignmentDetailDTO implements ITeacherAssignmentDetailDTO {
    teacherId?: string;
    teacherName?: string;
    academicYearId?: string;

    constructor(data?: ITeacherAssignmentDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.teacherName = _data["teacherName"];
            this.academicYearId = _data["academicYearId"];
        }
    }

    static fromJS(data: any): TeacherAssignmentDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherAssignmentDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["teacherName"] = this.teacherName;
        data["academicYearId"] = this.academicYearId;
        return data;
    }
}

export interface ITeacherAssignmentDetailDTO {
    teacherId?: string;
    teacherName?: string;
    academicYearId?: string;
}

export class CourseGradeMappingDTO implements ICourseGradeMappingDTO {
    courseId?: string;
    gradeLevelId?: string;
    isElective?: boolean | undefined;

    constructor(data?: ICourseGradeMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.gradeLevelId = _data["gradeLevelId"];
            this.isElective = _data["isElective"];
        }
    }

    static fromJS(data: any): CourseGradeMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseGradeMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["gradeLevelId"] = this.gradeLevelId;
        data["isElective"] = this.isElective;
        return data;
    }
}

export interface ICourseGradeMappingDTO {
    courseId?: string;
    gradeLevelId?: string;
    isElective?: boolean | undefined;
}

export class CourseMaterialDTO implements ICourseMaterialDTO {
    id?: string;
    title?: string;
    content?: string;
    lastModified?: Date;

    constructor(data?: ICourseMaterialDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseMaterialDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseMaterialDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICourseMaterialDTO {
    id?: string;
    title?: string;
    content?: string;
    lastModified?: Date;
}

export class EnrollmentTranscriptDTO implements IEnrollmentTranscriptDTO {
    enrollmentId?: string;
    studentId?: string;
    studentName?: string;
    branchName?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    statusHistory?: EnrollmentStatusHistoryDTO[];
    documents?: DocumentDTO[];

    constructor(data?: IEnrollmentTranscriptDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.studentId = _data["studentId"];
            this.studentName = _data["studentName"];
            this.branchName = _data["branchName"];
            this.status = _data["status"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["statusHistory"])) {
                this.statusHistory = [] as any;
                for (let item of _data["statusHistory"])
                    this.statusHistory!.push(EnrollmentStatusHistoryDTO.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnrollmentTranscriptDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentTranscriptDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["studentId"] = this.studentId;
        data["studentName"] = this.studentName;
        data["branchName"] = this.branchName;
        data["status"] = this.status;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.statusHistory)) {
            data["statusHistory"] = [];
            for (let item of this.statusHistory)
                data["statusHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEnrollmentTranscriptDTO {
    enrollmentId?: string;
    studentId?: string;
    studentName?: string;
    branchName?: string;
    status?: EnrollmentStatusEnum;
    submittedAt?: Date;
    statusHistory?: EnrollmentStatusHistoryDTO[];
    documents?: DocumentDTO[];
}

export class EnrollmentStatusHistoryDTO implements IEnrollmentStatusHistoryDTO {
    enrollmentId?: string;
    oldStatus?: EnrollmentStatusEnum;
    newStatus?: EnrollmentStatusEnum;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: EnrollmentChangeReasonEnum;

    constructor(data?: IEnrollmentStatusHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.oldStatus = _data["oldStatus"];
            this.newStatus = _data["newStatus"];
            this.changedBy = _data["changedBy"];
            this.changedAt = _data["changedAt"] ? new Date(_data["changedAt"].toString()) : <any>undefined;
            this.changeReason = _data["changeReason"];
        }
    }

    static fromJS(data: any): EnrollmentStatusHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentStatusHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["oldStatus"] = this.oldStatus;
        data["newStatus"] = this.newStatus;
        data["changedBy"] = this.changedBy;
        data["changedAt"] = this.changedAt ? this.changedAt.toISOString() : <any>undefined;
        data["changeReason"] = this.changeReason;
        return data;
    }
}

export interface IEnrollmentStatusHistoryDTO {
    enrollmentId?: string;
    oldStatus?: EnrollmentStatusEnum;
    newStatus?: EnrollmentStatusEnum;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: EnrollmentChangeReasonEnum;
}

export class PagedResultOfGradeHistoryDTO extends PagedResultBase implements IPagedResultOfGradeHistoryDTO {
    results?: GradeHistoryDTO[];

    constructor(data?: IPagedResultOfGradeHistoryDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GradeHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfGradeHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfGradeHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfGradeHistoryDTO extends IPagedResultBase {
    results?: GradeHistoryDTO[];
}

export class GradeHistoryDTO implements IGradeHistoryDTO {
    gradeId?: string;
    oldScore?: number;
    newScore?: number;
    modifiedBy?: string;
    modifiedAt?: Date;

    constructor(data?: IGradeHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.oldScore = _data["oldScore"];
            this.newScore = _data["newScore"];
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GradeHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["oldScore"] = this.oldScore;
        data["newScore"] = this.newScore;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGradeHistoryDTO {
    gradeId?: string;
    oldScore?: number;
    newScore?: number;
    modifiedBy?: string;
    modifiedAt?: Date;
}

export class GradeHistoryFilterDTO implements IGradeHistoryFilterDTO {
    gradeId?: string;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IGradeHistoryFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeId = _data["gradeId"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GradeHistoryFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeHistoryFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeId"] = this.gradeId;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IGradeHistoryFilterDTO {
    gradeId?: string;
    pageNumber?: number;
    pageSize?: number;
}

export class PagedResultOfGradeDTO extends PagedResultBase implements IPagedResultOfGradeDTO {
    results?: GradeDTO[];

    constructor(data?: IPagedResultOfGradeDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GradeDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfGradeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfGradeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfGradeDTO extends IPagedResultBase {
    results?: GradeDTO[];
}

export class GradeDTO implements IGradeDTO {
    id?: string;
    studentId?: string;
    courseId?: string;
    semesterId?: string;
    score?: number;
    gradeType?: GradeTypeEnum;
    teacherCommentFr?: string | undefined;
    teacherCommentAr?: string | undefined;
    teacherCommentEn?: string | undefined;

    constructor(data?: IGradeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.courseId = _data["courseId"];
            this.semesterId = _data["semesterId"];
            this.score = _data["score"];
            this.gradeType = _data["gradeType"];
            this.teacherCommentFr = _data["teacherCommentFr"];
            this.teacherCommentAr = _data["teacherCommentAr"];
            this.teacherCommentEn = _data["teacherCommentEn"];
        }
    }

    static fromJS(data: any): GradeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["courseId"] = this.courseId;
        data["semesterId"] = this.semesterId;
        data["score"] = this.score;
        data["gradeType"] = this.gradeType;
        data["teacherCommentFr"] = this.teacherCommentFr;
        data["teacherCommentAr"] = this.teacherCommentAr;
        data["teacherCommentEn"] = this.teacherCommentEn;
        return data;
    }
}

export interface IGradeDTO {
    id?: string;
    studentId?: string;
    courseId?: string;
    semesterId?: string;
    score?: number;
    gradeType?: GradeTypeEnum;
    teacherCommentFr?: string | undefined;
    teacherCommentAr?: string | undefined;
    teacherCommentEn?: string | undefined;
}

export enum GradeTypeEnum {
    Exam = "Exam",
    Assignment = "Assignment",
    Quiz = "Quiz",
    OralTest = "OralTest",
}

export class GradeFilterDTO implements IGradeFilterDTO {
    studentId?: string | undefined;
    courseId?: string | undefined;
    semesterId?: string | undefined;
    minScore?: number | undefined;
    maxScore?: number | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IGradeFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.courseId = _data["courseId"];
            this.semesterId = _data["semesterId"];
            this.minScore = _data["minScore"];
            this.maxScore = _data["maxScore"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): GradeFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["courseId"] = this.courseId;
        data["semesterId"] = this.semesterId;
        data["minScore"] = this.minScore;
        data["maxScore"] = this.maxScore;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IGradeFilterDTO {
    studentId?: string | undefined;
    courseId?: string | undefined;
    semesterId?: string | undefined;
    minScore?: number | undefined;
    maxScore?: number | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export class GradeStatisticsDTO implements IGradeStatisticsDTO {
    averageScore?: number;
    maxScore?: number;
    minScore?: number;
    gradeDistribution?: GradeDistributionDTO[];

    constructor(data?: IGradeStatisticsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.averageScore = _data["averageScore"];
            this.maxScore = _data["maxScore"];
            this.minScore = _data["minScore"];
            if (Array.isArray(_data["gradeDistribution"])) {
                this.gradeDistribution = [] as any;
                for (let item of _data["gradeDistribution"])
                    this.gradeDistribution!.push(GradeDistributionDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeStatisticsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeStatisticsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageScore"] = this.averageScore;
        data["maxScore"] = this.maxScore;
        data["minScore"] = this.minScore;
        if (Array.isArray(this.gradeDistribution)) {
            data["gradeDistribution"] = [];
            for (let item of this.gradeDistribution)
                data["gradeDistribution"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGradeStatisticsDTO {
    averageScore?: number;
    maxScore?: number;
    minScore?: number;
    gradeDistribution?: GradeDistributionDTO[];
}

export class GradeDistributionDTO implements IGradeDistributionDTO {
    gradeType?: GradeTypeEnum;
    count?: number;
    average?: number;

    constructor(data?: IGradeDistributionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeType = _data["gradeType"];
            this.count = _data["count"];
            this.average = _data["average"];
        }
    }

    static fromJS(data: any): GradeDistributionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDistributionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeType"] = this.gradeType;
        data["count"] = this.count;
        data["average"] = this.average;
        return data;
    }
}

export interface IGradeDistributionDTO {
    gradeType?: GradeTypeEnum;
    count?: number;
    average?: number;
}

export class GpaDTO implements IGpaDTO {
    studentId?: string;
    gpa?: number;

    constructor(data?: IGpaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.gpa = _data["gpa"];
        }
    }

    static fromJS(data: any): GpaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GpaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["gpa"] = this.gpa;
        return data;
    }
}

export interface IGpaDTO {
    studentId?: string;
    gpa?: number;
}

export class PagedResultOfGradeResourceDTO extends PagedResultBase implements IPagedResultOfGradeResourceDTO {
    results?: GradeResourceDTO[];

    constructor(data?: IPagedResultOfGradeResourceDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GradeResourceDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfGradeResourceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfGradeResourceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfGradeResourceDTO extends IPagedResultBase {
    results?: GradeResourceDTO[];
}

export class GradeResourceDTO implements IGradeResourceDTO {
    id?: string;
    gradeLevelId?: string;
    bookId?: string | undefined;
    schoolSupplyId?: string | undefined;
    supplyQuantity?: number | undefined;
    gradeLevelName?: string;
    resourceTitle?: string;

    constructor(data?: IGradeResourceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gradeLevelId = _data["gradeLevelId"];
            this.bookId = _data["bookId"];
            this.schoolSupplyId = _data["schoolSupplyId"];
            this.supplyQuantity = _data["supplyQuantity"];
            this.gradeLevelName = _data["gradeLevelName"];
            this.resourceTitle = _data["resourceTitle"];
        }
    }

    static fromJS(data: any): GradeResourceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeResourceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gradeLevelId"] = this.gradeLevelId;
        data["bookId"] = this.bookId;
        data["schoolSupplyId"] = this.schoolSupplyId;
        data["supplyQuantity"] = this.supplyQuantity;
        data["gradeLevelName"] = this.gradeLevelName;
        data["resourceTitle"] = this.resourceTitle;
        return data;
    }
}

export interface IGradeResourceDTO {
    id?: string;
    gradeLevelId?: string;
    bookId?: string | undefined;
    schoolSupplyId?: string | undefined;
    supplyQuantity?: number | undefined;
    gradeLevelName?: string;
    resourceTitle?: string;
}

export class ResourceFilterDTO implements IResourceFilterDTO {
    gradeLevelId?: string | undefined;
    resourceType?: ResourceType | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IResourceFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gradeLevelId = _data["gradeLevelId"];
            this.resourceType = _data["resourceType"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResourceFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gradeLevelId"] = this.gradeLevelId;
        data["resourceType"] = this.resourceType;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResourceFilterDTO {
    gradeLevelId?: string | undefined;
    resourceType?: ResourceType | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export enum ResourceType {
    Book = "Book",
    SchoolSupply = "SchoolSupply",
}

export class ScheduleDTO implements IScheduleDTO {
    id?: string;
    courseId?: string;
    gradeSectionId?: string;
    classroomId?: string;
    teacherId?: string;
    dayOfWeek?: DayOfWeek;
    startTime?: string;
    endTime?: string;
    duration?: string;

    constructor(data?: IScheduleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.gradeSectionId = _data["gradeSectionId"];
            this.classroomId = _data["classroomId"];
            this.teacherId = _data["teacherId"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): ScheduleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["gradeSectionId"] = this.gradeSectionId;
        data["classroomId"] = this.classroomId;
        data["teacherId"] = this.teacherId;
        data["dayOfWeek"] = this.dayOfWeek;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["duration"] = this.duration;
        return data;
    }
}

export interface IScheduleDTO {
    id?: string;
    courseId?: string;
    gradeSectionId?: string;
    classroomId?: string;
    teacherId?: string;
    dayOfWeek?: DayOfWeek;
    startTime?: string;
    endTime?: string;
    duration?: string;
}

export enum DayOfWeek {
    Sunday = "Sunday",
    Monday = "Monday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday",
    Thursday = "Thursday",
    Friday = "Friday",
    Saturday = "Saturday",
}

export class TransferEligibilityResultDTO implements ITransferEligibilityResultDTO {
    isEligible?: boolean;
    pendingFees?: boolean;
    disciplinaryIssues?: boolean;

    constructor(data?: ITransferEligibilityResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEligible = _data["isEligible"];
            this.pendingFees = _data["pendingFees"];
            this.disciplinaryIssues = _data["disciplinaryIssues"];
        }
    }

    static fromJS(data: any): TransferEligibilityResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferEligibilityResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEligible"] = this.isEligible;
        data["pendingFees"] = this.pendingFees;
        data["disciplinaryIssues"] = this.disciplinaryIssues;
        return data;
    }
}

export interface ITransferEligibilityResultDTO {
    isEligible?: boolean;
    pendingFees?: boolean;
    disciplinaryIssues?: boolean;
}

export class TransferRequestDetailDTO implements ITransferRequestDetailDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    reason?: string | undefined;
    status?: TransferRequestStatus;
    submittedAt?: Date;
    documents?: DocumentDTO[];
    history?: TransferRequestHistoryDTO[];

    constructor(data?: ITransferRequestDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fromBranchId = _data["fromBranchId"];
            this.toBranchId = _data["toBranchId"];
            this.fromSchoolId = _data["fromSchoolId"];
            this.toSchoolId = _data["toSchoolId"];
            this.reason = _data["reason"];
            this.status = _data["status"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(TransferRequestHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransferRequestDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRequestDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fromBranchId"] = this.fromBranchId;
        data["toBranchId"] = this.toBranchId;
        data["fromSchoolId"] = this.fromSchoolId;
        data["toSchoolId"] = this.toSchoolId;
        data["reason"] = this.reason;
        data["status"] = this.status;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransferRequestDetailDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    reason?: string | undefined;
    status?: TransferRequestStatus;
    submittedAt?: Date;
    documents?: DocumentDTO[];
    history?: TransferRequestHistoryDTO[];
}

export enum TransferRequestStatus {
    None = "None",
    Pending = "Pending",
    UnderReview = "UnderReview",
    Approved = "Approved",
    Rejected = "Rejected",
    Completed = "Completed",
    Canceled = "Canceled",
}

export class TransferRequestHistoryDTO implements ITransferRequestHistoryDTO {
    transferRequestId?: string;
    oldStatus?: TransferRequestStatus;
    newStatus?: TransferRequestStatus;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: TransferRequestChangeReasonEnum;
    reason?: string;

    constructor(data?: ITransferRequestHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferRequestId = _data["transferRequestId"];
            this.oldStatus = _data["oldStatus"];
            this.newStatus = _data["newStatus"];
            this.changedBy = _data["changedBy"];
            this.changedAt = _data["changedAt"] ? new Date(_data["changedAt"].toString()) : <any>undefined;
            this.changeReason = _data["changeReason"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): TransferRequestHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRequestHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferRequestId"] = this.transferRequestId;
        data["oldStatus"] = this.oldStatus;
        data["newStatus"] = this.newStatus;
        data["changedBy"] = this.changedBy;
        data["changedAt"] = this.changedAt ? this.changedAt.toISOString() : <any>undefined;
        data["changeReason"] = this.changeReason;
        data["reason"] = this.reason;
        return data;
    }
}

export interface ITransferRequestHistoryDTO {
    transferRequestId?: string;
    oldStatus?: TransferRequestStatus;
    newStatus?: TransferRequestStatus;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: TransferRequestChangeReasonEnum;
    reason?: string;
}

export enum TransferRequestChangeReasonEnum {
    NewRequest = "NewRequest",
    ReEvaluated = "ReEvaluated",
    Edited = "Edited",
    Other = "Other",
    Reassignment = "Reassignment",
    Canceled = "Canceled",
}

export class PagedResultOfTransferRequestHistoryDTO extends PagedResultBase implements IPagedResultOfTransferRequestHistoryDTO {
    results?: TransferRequestHistoryDTO[];

    constructor(data?: IPagedResultOfTransferRequestHistoryDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TransferRequestHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfTransferRequestHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfTransferRequestHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfTransferRequestHistoryDTO extends IPagedResultBase {
    results?: TransferRequestHistoryDTO[];
}

export class TransferHistoryFilterDTO implements ITransferHistoryFilterDTO {
    transferRequestId?: string;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: ITransferHistoryFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferRequestId = _data["transferRequestId"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): TransferHistoryFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferHistoryFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferRequestId"] = this.transferRequestId;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface ITransferHistoryFilterDTO {
    transferRequestId?: string;
    pageNumber?: number;
    pageSize?: number;
}

export class TransferRequestDTO implements ITransferRequestDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    status?: TransferRequestStatus;
    documents?: DocumentDTO[] | undefined;
    reason?: string | undefined;
    submittedAt?: Date;
    adminComment?: string | undefined;

    constructor(data?: ITransferRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fromBranchId = _data["fromBranchId"];
            this.toBranchId = _data["toBranchId"];
            this.fromSchoolId = _data["fromSchoolId"];
            this.toSchoolId = _data["toSchoolId"];
            this.status = _data["status"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
            this.reason = _data["reason"];
            this.submittedAt = _data["submittedAt"] ? new Date(_data["submittedAt"].toString()) : <any>undefined;
            this.adminComment = _data["adminComment"];
        }
    }

    static fromJS(data: any): TransferRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fromBranchId"] = this.fromBranchId;
        data["toBranchId"] = this.toBranchId;
        data["fromSchoolId"] = this.fromSchoolId;
        data["toSchoolId"] = this.toSchoolId;
        data["status"] = this.status;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["reason"] = this.reason;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["adminComment"] = this.adminComment;
        return data;
    }
}

export interface ITransferRequestDTO {
    studentId?: string;
    fromBranchId?: string;
    toBranchId?: string;
    fromSchoolId?: string | undefined;
    toSchoolId?: string | undefined;
    status?: TransferRequestStatus;
    documents?: DocumentDTO[] | undefined;
    reason?: string | undefined;
    submittedAt?: Date;
    adminComment?: string | undefined;
}

export class PagedResultOfAttendanceHistoryDTO extends PagedResultBase implements IPagedResultOfAttendanceHistoryDTO {
    results?: AttendanceHistoryDTO[];

    constructor(data?: IPagedResultOfAttendanceHistoryDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AttendanceHistoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfAttendanceHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAttendanceHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfAttendanceHistoryDTO extends IPagedResultBase {
    results?: AttendanceHistoryDTO[];
}

export class AttendanceHistoryDTO implements IAttendanceHistoryDTO {
    attendanceId?: string;
    studentId?: string;
    date?: Date;
    status?: AttendanceEnum;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: AttendanceChangeReasonEnum;

    constructor(data?: IAttendanceHistoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attendanceId = _data["attendanceId"];
            this.studentId = _data["studentId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.changedBy = _data["changedBy"];
            this.changedAt = _data["changedAt"] ? new Date(_data["changedAt"].toString()) : <any>undefined;
            this.changeReason = _data["changeReason"];
        }
    }

    static fromJS(data: any): AttendanceHistoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceHistoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attendanceId"] = this.attendanceId;
        data["studentId"] = this.studentId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["changedBy"] = this.changedBy;
        data["changedAt"] = this.changedAt ? this.changedAt.toISOString() : <any>undefined;
        data["changeReason"] = this.changeReason;
        return data;
    }
}

export interface IAttendanceHistoryDTO {
    attendanceId?: string;
    studentId?: string;
    date?: Date;
    status?: AttendanceEnum;
    changedBy?: string;
    changedAt?: Date;
    changeReason?: AttendanceChangeReasonEnum;
}

export class AttendanceHistoryFilterDTO implements IAttendanceHistoryFilterDTO {
    studentId?: string | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    changeReason?: AttendanceChangeReasonEnum | undefined;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IAttendanceHistoryFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
            this.changeReason = _data["changeReason"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): AttendanceHistoryFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceHistoryFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["changeReason"] = this.changeReason;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IAttendanceHistoryFilterDTO {
    studentId?: string | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    changeReason?: AttendanceChangeReasonEnum | undefined;
    pageNumber?: number;
    pageSize?: number;
}

export class GradeLevelDTO implements IGradeLevelDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    description?: string | undefined;
    educationalStage?: EducationalStageEnum | undefined;
    courseGradeMappings?: CourseDTO[] | undefined;

    constructor(data?: IGradeLevelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleFr = _data["titleFr"];
            this.titleAr = _data["titleAr"];
            this.titleEn = _data["titleEn"];
            this.description = _data["description"];
            this.educationalStage = _data["educationalStage"];
            if (Array.isArray(_data["courseGradeMappings"])) {
                this.courseGradeMappings = [] as any;
                for (let item of _data["courseGradeMappings"])
                    this.courseGradeMappings!.push(CourseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeLevelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeLevelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleFr"] = this.titleFr;
        data["titleAr"] = this.titleAr;
        data["titleEn"] = this.titleEn;
        data["description"] = this.description;
        data["educationalStage"] = this.educationalStage;
        if (Array.isArray(this.courseGradeMappings)) {
            data["courseGradeMappings"] = [];
            for (let item of this.courseGradeMappings)
                data["courseGradeMappings"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGradeLevelDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    description?: string | undefined;
    educationalStage?: EducationalStageEnum | undefined;
    courseGradeMappings?: CourseDTO[] | undefined;
}

export enum EducationalStageEnum {
    Primary = "Primary",
    Secondary = "Secondary",
    PreSchool = "PreSchool",
    HighSchool = "HighSchool",
}

export class PagedResultOfGradeLevelDTO extends PagedResultBase implements IPagedResultOfGradeLevelDTO {
    results?: GradeLevelDTO[];

    constructor(data?: IPagedResultOfGradeLevelDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GradeLevelDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfGradeLevelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfGradeLevelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfGradeLevelDTO extends IPagedResultBase {
    results?: GradeLevelDTO[];
}

export class GradeUpdateDTO implements IGradeUpdateDTO {
    score?: number;
    gradeType?: GradeTypeEnum;
    teacherCommentFr?: string | undefined;
    teacherCommentAr?: string | undefined;
    teacherCommentEn?: string | undefined;

    constructor(data?: IGradeUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data["score"];
            this.gradeType = _data["gradeType"];
            this.teacherCommentFr = _data["teacherCommentFr"];
            this.teacherCommentAr = _data["teacherCommentAr"];
            this.teacherCommentEn = _data["teacherCommentEn"];
        }
    }

    static fromJS(data: any): GradeUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GradeUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["gradeType"] = this.gradeType;
        data["teacherCommentFr"] = this.teacherCommentFr;
        data["teacherCommentAr"] = this.teacherCommentAr;
        data["teacherCommentEn"] = this.teacherCommentEn;
        return data;
    }
}

export interface IGradeUpdateDTO {
    score?: number;
    gradeType?: GradeTypeEnum;
    teacherCommentFr?: string | undefined;
    teacherCommentAr?: string | undefined;
    teacherCommentEn?: string | undefined;
}

export class BulkGradeDTO implements IBulkGradeDTO {
    records?: GradeDTO[];

    constructor(data?: IBulkGradeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(GradeDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkGradeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BulkGradeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBulkGradeDTO {
    records?: GradeDTO[];
}

export class BulkParentDTO implements IBulkParentDTO {
    records?: ParentDTO[];
    initiatedBy?: string;

    constructor(data?: IBulkParentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(ParentDTO.fromJS(item));
            }
            this.initiatedBy = _data["initiatedBy"];
        }
    }

    static fromJS(data: any): BulkParentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BulkParentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        data["initiatedBy"] = this.initiatedBy;
        return data;
    }
}

export interface IBulkParentDTO {
    records?: ParentDTO[];
    initiatedBy?: string;
}

export class PagedResultOfParentDTO extends PagedResultBase implements IPagedResultOfParentDTO {
    results?: ParentDTO[];

    constructor(data?: IPagedResultOfParentDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ParentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfParentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfParentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfParentDTO extends IPagedResultBase {
    results?: ParentDTO[];
}

export class ParentVerificationDTO implements IParentVerificationDTO {
    cin?: string;
    verifiedBy?: string;

    constructor(data?: IParentVerificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cin = _data["cin"];
            this.verifiedBy = _data["verifiedBy"];
        }
    }

    static fromJS(data: any): ParentVerificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ParentVerificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cin"] = this.cin;
        data["verifiedBy"] = this.verifiedBy;
        return data;
    }
}

export interface IParentVerificationDTO {
    cin?: string;
    verifiedBy?: string;
}

export class PagedResultOfParsedStudentDto extends PagedResultBase implements IPagedResultOfParsedStudentDto {
    results?: ParsedStudentDto[];

    constructor(data?: IPagedResultOfParsedStudentDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ParsedStudentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfParsedStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfParsedStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfParsedStudentDto extends IPagedResultBase {
    results?: ParsedStudentDto[];
}

export class ParsedStudentDto extends StudentDTO implements IParsedStudentDto {
    isEnrolled?: boolean;

    constructor(data?: IParsedStudentDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isEnrolled = _data["isEnrolled"];
        }
    }

    static fromJS(data: any): ParsedStudentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParsedStudentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnrolled"] = this.isEnrolled;
        super.toJSON(data);
        return data;
    }
}

export interface IParsedStudentDto extends IStudentDTO {
    isEnrolled?: boolean;
}

export class ParentDashboardDTO implements IParentDashboardDTO {
    parentId?: string;
    notifications?: NotificationDTO[];
    students?: AssociatedStudentStatusDTO[];
    recentActivities?: RecentActivityDTO[];

    constructor(data?: IParentDashboardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationDTO.fromJS(item));
            }
            if (Array.isArray(_data["students"])) {
                this.students = [] as any;
                for (let item of _data["students"])
                    this.students!.push(AssociatedStudentStatusDTO.fromJS(item));
            }
            if (Array.isArray(_data["recentActivities"])) {
                this.recentActivities = [] as any;
                for (let item of _data["recentActivities"])
                    this.recentActivities!.push(RecentActivityDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentDashboardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ParentDashboardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        if (Array.isArray(this.students)) {
            data["students"] = [];
            for (let item of this.students)
                data["students"].push(item.toJSON());
        }
        if (Array.isArray(this.recentActivities)) {
            data["recentActivities"] = [];
            for (let item of this.recentActivities)
                data["recentActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IParentDashboardDTO {
    parentId?: string;
    notifications?: NotificationDTO[];
    students?: AssociatedStudentStatusDTO[];
    recentActivities?: RecentActivityDTO[];
}

export class NotificationDTO implements INotificationDTO {
    notificationId?: string;
    title?: string;
    message?: string;
    isRead?: boolean;
    createdAt?: Date;

    constructor(data?: INotificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationId = _data["notificationId"];
            this.title = _data["title"];
            this.message = _data["message"];
            this.isRead = _data["isRead"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        data["title"] = this.title;
        data["message"] = this.message;
        data["isRead"] = this.isRead;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface INotificationDTO {
    notificationId?: string;
    title?: string;
    message?: string;
    isRead?: boolean;
    createdAt?: Date;
}

export class AssociatedStudentStatusDTO implements IAssociatedStudentStatusDTO {
    studentId?: string;
    fullName?: string;
    status?: string;

    constructor(data?: IAssociatedStudentStatusDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fullName = _data["fullName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): AssociatedStudentStatusDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AssociatedStudentStatusDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fullName"] = this.fullName;
        data["status"] = this.status;
        return data;
    }
}

export interface IAssociatedStudentStatusDTO {
    studentId?: string;
    fullName?: string;
    status?: string;
}

export class RecentActivityDTO implements IRecentActivityDTO {
    actionDate?: Date;
    actionType?: string;
    details?: string;

    constructor(data?: IRecentActivityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionDate = _data["actionDate"] ? new Date(_data["actionDate"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): RecentActivityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RecentActivityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["details"] = this.details;
        return data;
    }
}

export interface IRecentActivityDTO {
    actionDate?: Date;
    actionType?: string;
    details?: string;
}

export class ParentProfileDTO implements IParentProfileDTO {
    parentId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    email?: string;
    phone?: string;
    occupation?: string;
    associatedStudentsCount?: number;
    children?: StudentDTO[];

    constructor(data?: IParentProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.fullNameFr = _data["fullNameFr"];
            this.fullNameAr = _data["fullNameAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.occupation = _data["occupation"];
            this.associatedStudentsCount = _data["associatedStudentsCount"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(StudentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParentProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ParentProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["fullNameFr"] = this.fullNameFr;
        data["fullNameAr"] = this.fullNameAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["occupation"] = this.occupation;
        data["associatedStudentsCount"] = this.associatedStudentsCount;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IParentProfileDTO {
    parentId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    email?: string;
    phone?: string;
    occupation?: string;
    associatedStudentsCount?: number;
    children?: StudentDTO[];
}

export class StudentDashboardDTO implements IStudentDashboardDTO {
    studentId?: string;
    fullNameFR?: string;
    fullNameAR?: string;
    gpa?: number;
    totalAbsences?: number;
    totalLate?: number;
    courses?: DashboardCourseDTO[];

    constructor(data?: IStudentDashboardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fullNameFR = _data["fullNameFR"];
            this.fullNameAR = _data["fullNameAR"];
            this.gpa = _data["gpa"];
            this.totalAbsences = _data["totalAbsences"];
            this.totalLate = _data["totalLate"];
            if (Array.isArray(_data["courses"])) {
                this.courses = [] as any;
                for (let item of _data["courses"])
                    this.courses!.push(DashboardCourseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentDashboardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDashboardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fullNameFR"] = this.fullNameFR;
        data["fullNameAR"] = this.fullNameAR;
        data["gpa"] = this.gpa;
        data["totalAbsences"] = this.totalAbsences;
        data["totalLate"] = this.totalLate;
        if (Array.isArray(this.courses)) {
            data["courses"] = [];
            for (let item of this.courses)
                data["courses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStudentDashboardDTO {
    studentId?: string;
    fullNameFR?: string;
    fullNameAR?: string;
    gpa?: number;
    totalAbsences?: number;
    totalLate?: number;
    courses?: DashboardCourseDTO[];
}

export class DashboardCourseDTO implements IDashboardCourseDTO {
    courseId?: string;
    courseNameFr?: string;
    courseNameAr?: string;
    teacherNameFr?: string;
    teacherNameAr?: string;
    schedule?: string;

    constructor(data?: IDashboardCourseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.courseNameFr = _data["courseNameFr"];
            this.courseNameAr = _data["courseNameAr"];
            this.teacherNameFr = _data["teacherNameFr"];
            this.teacherNameAr = _data["teacherNameAr"];
            this.schedule = _data["schedule"];
        }
    }

    static fromJS(data: any): DashboardCourseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardCourseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["courseNameFr"] = this.courseNameFr;
        data["courseNameAr"] = this.courseNameAr;
        data["teacherNameFr"] = this.teacherNameFr;
        data["teacherNameAr"] = this.teacherNameAr;
        data["schedule"] = this.schedule;
        return data;
    }
}

export interface IDashboardCourseDTO {
    courseId?: string;
    courseNameFr?: string;
    courseNameAr?: string;
    teacherNameFr?: string;
    teacherNameAr?: string;
    schedule?: string;
}

export class StudentProfileDTO implements IStudentProfileDTO {
    studentId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    dateOfBirth?: Date;
    gradeSectionFr?: string;
    grafeSectionAr?: string;
    gradeLevelFr?: string;
    gradeLevelAr?: string;
    email?: string;
    phone?: string;
    status?: string;

    constructor(data?: IStudentProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.fullNameFr = _data["fullNameFr"];
            this.fullNameAr = _data["fullNameAr"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gradeSectionFr = _data["gradeSectionFr"];
            this.grafeSectionAr = _data["grafeSectionAr"];
            this.gradeLevelFr = _data["gradeLevelFr"];
            this.gradeLevelAr = _data["gradeLevelAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): StudentProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["fullNameFr"] = this.fullNameFr;
        data["fullNameAr"] = this.fullNameAr;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gradeSectionFr"] = this.gradeSectionFr;
        data["grafeSectionAr"] = this.grafeSectionAr;
        data["gradeLevelFr"] = this.gradeLevelFr;
        data["gradeLevelAr"] = this.gradeLevelAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["status"] = this.status;
        return data;
    }
}

export interface IStudentProfileDTO {
    studentId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    dateOfBirth?: Date;
    gradeSectionFr?: string;
    grafeSectionAr?: string;
    gradeLevelFr?: string;
    gradeLevelAr?: string;
    email?: string;
    phone?: string;
    status?: string;
}

export class StaffDashboardDTO implements IStaffDashboardDTO {
    staffId?: string;
    fullName?: string;
    jobTitle?: string;
    department?: string;
    notificationsCount?: number;
    recentActivity?: StaffAuditDTO[];

    constructor(data?: IStaffDashboardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.fullName = _data["fullName"];
            this.jobTitle = _data["jobTitle"];
            this.department = _data["department"];
            this.notificationsCount = _data["notificationsCount"];
            if (Array.isArray(_data["recentActivity"])) {
                this.recentActivity = [] as any;
                for (let item of _data["recentActivity"])
                    this.recentActivity!.push(StaffAuditDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StaffDashboardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDashboardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["fullName"] = this.fullName;
        data["jobTitle"] = this.jobTitle;
        data["department"] = this.department;
        data["notificationsCount"] = this.notificationsCount;
        if (Array.isArray(this.recentActivity)) {
            data["recentActivity"] = [];
            for (let item of this.recentActivity)
                data["recentActivity"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStaffDashboardDTO {
    staffId?: string;
    fullName?: string;
    jobTitle?: string;
    department?: string;
    notificationsCount?: number;
    recentActivity?: StaffAuditDTO[];
}

export class StaffAuditDTO implements IStaffAuditDTO {
    actionDate?: Date;
    actionType?: StaffActionType;
    details?: string;
    performedBy?: string;

    constructor(data?: IStaffAuditDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionDate = _data["actionDate"] ? new Date(_data["actionDate"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.details = _data["details"];
            this.performedBy = _data["performedBy"];
        }
    }

    static fromJS(data: any): StaffAuditDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StaffAuditDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["details"] = this.details;
        data["performedBy"] = this.performedBy;
        return data;
    }
}

export interface IStaffAuditDTO {
    actionDate?: Date;
    actionType?: StaffActionType;
    details?: string;
    performedBy?: string;
}

export enum StaffActionType {
    Created = "Created",
    Updated = "Updated",
    Deleted = "Deleted",
    RoleChanged = "RoleChanged",
}

export class StaffProfileDTO implements IStaffProfileDTO {
    staffId?: string;
    fullName?: string;
    email?: string;
    phone?: string;
    department?: string;
    jobTitle?: string;
    role?: StaffRole;
    auditLogs?: StaffAuditDTO[];

    constructor(data?: IStaffProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.department = _data["department"];
            this.jobTitle = _data["jobTitle"];
            this.role = _data["role"];
            if (Array.isArray(_data["auditLogs"])) {
                this.auditLogs = [] as any;
                for (let item of _data["auditLogs"])
                    this.auditLogs!.push(StaffAuditDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StaffProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StaffProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["department"] = this.department;
        data["jobTitle"] = this.jobTitle;
        data["role"] = this.role;
        if (Array.isArray(this.auditLogs)) {
            data["auditLogs"] = [];
            for (let item of this.auditLogs)
                data["auditLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStaffProfileDTO {
    staffId?: string;
    fullName?: string;
    email?: string;
    phone?: string;
    department?: string;
    jobTitle?: string;
    role?: StaffRole;
    auditLogs?: StaffAuditDTO[];
}

export enum StaffRole {
    Administrator = "Administrator",
    AcademicManager = "AcademicManager",
    SupportStaff = "SupportStaff",
    FinanceOfficer = "FinanceOfficer",
}

export class TeacherDashboardDTO implements ITeacherDashboardDTO {
    teacherId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    courseCount?: number;
    assignedCourses?: CourseDTO[];

    constructor(data?: ITeacherDashboardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.fullNameFr = _data["fullNameFr"];
            this.fullNameAr = _data["fullNameAr"];
            this.courseCount = _data["courseCount"];
            if (Array.isArray(_data["assignedCourses"])) {
                this.assignedCourses = [] as any;
                for (let item of _data["assignedCourses"])
                    this.assignedCourses!.push(CourseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherDashboardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDashboardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["fullNameFr"] = this.fullNameFr;
        data["fullNameAr"] = this.fullNameAr;
        data["courseCount"] = this.courseCount;
        if (Array.isArray(this.assignedCourses)) {
            data["assignedCourses"] = [];
            for (let item of this.assignedCourses)
                data["assignedCourses"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITeacherDashboardDTO {
    teacherId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    courseCount?: number;
    assignedCourses?: CourseDTO[];
}

export class TeacherProfileDTO implements ITeacherProfileDTO {
    teacherId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    email?: string;
    phone?: string;
    hireDate?: Date;
    specializationFr?: string;
    specializationAr?: string;
    status?: TeacherStatusEnum;
    courses?: CourseScheduleDTO[];

    constructor(data?: ITeacherProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teacherId = _data["teacherId"];
            this.fullNameFr = _data["fullNameFr"];
            this.fullNameAr = _data["fullNameAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.specializationFr = _data["specializationFr"];
            this.specializationAr = _data["specializationAr"];
            this.status = _data["status"];
            if (Array.isArray(_data["courses"])) {
                this.courses = [] as any;
                for (let item of _data["courses"])
                    this.courses!.push(CourseScheduleDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeacherProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teacherId"] = this.teacherId;
        data["fullNameFr"] = this.fullNameFr;
        data["fullNameAr"] = this.fullNameAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["specializationFr"] = this.specializationFr;
        data["specializationAr"] = this.specializationAr;
        data["status"] = this.status;
        if (Array.isArray(this.courses)) {
            data["courses"] = [];
            for (let item of this.courses)
                data["courses"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITeacherProfileDTO {
    teacherId?: string;
    fullNameFr?: string;
    fullNameAr?: string;
    email?: string;
    phone?: string;
    hireDate?: Date;
    specializationFr?: string;
    specializationAr?: string;
    status?: TeacherStatusEnum;
    courses?: CourseScheduleDTO[];
}

export enum TeacherStatusEnum {
    Active = "Active",
    OnLeave = "OnLeave",
    Suspended = "Suspended",
}

export class CourseScheduleDTO implements ICourseScheduleDTO {
    courseId?: string;
    courseNameFr?: string;
    courseNameAr?: string;
    description?: string | undefined;
    gradeId?: string;
    gradeNameFr?: string;
    gradeNameAr?: string;
    schedule?: ScheduleItemDTO[];

    constructor(data?: ICourseScheduleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.courseNameFr = _data["courseNameFr"];
            this.courseNameAr = _data["courseNameAr"];
            this.description = _data["description"];
            this.gradeId = _data["gradeId"];
            this.gradeNameFr = _data["gradeNameFr"];
            this.gradeNameAr = _data["gradeNameAr"];
            if (Array.isArray(_data["schedule"])) {
                this.schedule = [] as any;
                for (let item of _data["schedule"])
                    this.schedule!.push(ScheduleItemDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseScheduleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CourseScheduleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["courseNameFr"] = this.courseNameFr;
        data["courseNameAr"] = this.courseNameAr;
        data["description"] = this.description;
        data["gradeId"] = this.gradeId;
        data["gradeNameFr"] = this.gradeNameFr;
        data["gradeNameAr"] = this.gradeNameAr;
        if (Array.isArray(this.schedule)) {
            data["schedule"] = [];
            for (let item of this.schedule)
                data["schedule"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseScheduleDTO {
    courseId?: string;
    courseNameFr?: string;
    courseNameAr?: string;
    description?: string | undefined;
    gradeId?: string;
    gradeNameFr?: string;
    gradeNameAr?: string;
    schedule?: ScheduleItemDTO[];
}

export class ScheduleItemDTO implements IScheduleItemDTO {
    id?: string;
    dayOfWeek?: DayOfWeek;
    startTime?: string;
    endTime?: string;
    duration?: string;
    classroomId?: string;
    classroomName?: string;

    constructor(data?: IScheduleItemDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.duration = _data["duration"];
            this.classroomId = _data["classroomId"];
            this.classroomName = _data["classroomName"];
        }
    }

    static fromJS(data: any): ScheduleItemDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleItemDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dayOfWeek"] = this.dayOfWeek;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["duration"] = this.duration;
        data["classroomId"] = this.classroomId;
        data["classroomName"] = this.classroomName;
        return data;
    }
}

export interface IScheduleItemDTO {
    id?: string;
    dayOfWeek?: DayOfWeek;
    startTime?: string;
    endTime?: string;
    duration?: string;
    classroomId?: string;
    classroomName?: string;
}

export class CityDTO implements ICityDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    regionId?: string;

    constructor(data?: ICityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameFr = _data["nameFr"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.regionId = _data["regionId"];
        }
    }

    static fromJS(data: any): CityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameFr"] = this.nameFr;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["regionId"] = this.regionId;
        return data;
    }
}

export interface ICityDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    regionId?: string;
}

export class RegionDTO implements IRegionDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;

    constructor(data?: IRegionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameFr = _data["nameFr"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
        }
    }

    static fromJS(data: any): RegionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameFr"] = this.nameFr;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        return data;
    }
}

export interface IRegionDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
}

export class SchoolMetadataDTO implements ISchoolMetadataDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    code?: string;
    addressFr?: string;
    addressAr?: string;
    addressEn?: string;
    regionId?: string;
    regionNameFr?: string;
    regionNameAr?: string;
    regionNameEn?: string;
    cityId?: string;
    cityNameFr?: string;
    cityNameAr?: string;
    cityNameEn?: string;
    useIsolatedDatabase?: boolean;
    hasCustomConnectionString?: boolean;
    logoUrl?: string;
    timeZoneId?: string;

    constructor(data?: ISchoolMetadataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameFr = _data["nameFr"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.code = _data["code"];
            this.addressFr = _data["addressFr"];
            this.addressAr = _data["addressAr"];
            this.addressEn = _data["addressEn"];
            this.regionId = _data["regionId"];
            this.regionNameFr = _data["regionNameFr"];
            this.regionNameAr = _data["regionNameAr"];
            this.regionNameEn = _data["regionNameEn"];
            this.cityId = _data["cityId"];
            this.cityNameFr = _data["cityNameFr"];
            this.cityNameAr = _data["cityNameAr"];
            this.cityNameEn = _data["cityNameEn"];
            this.useIsolatedDatabase = _data["useIsolatedDatabase"];
            this.hasCustomConnectionString = _data["hasCustomConnectionString"];
            this.logoUrl = _data["logoUrl"];
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): SchoolMetadataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolMetadataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameFr"] = this.nameFr;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["code"] = this.code;
        data["addressFr"] = this.addressFr;
        data["addressAr"] = this.addressAr;
        data["addressEn"] = this.addressEn;
        data["regionId"] = this.regionId;
        data["regionNameFr"] = this.regionNameFr;
        data["regionNameAr"] = this.regionNameAr;
        data["regionNameEn"] = this.regionNameEn;
        data["cityId"] = this.cityId;
        data["cityNameFr"] = this.cityNameFr;
        data["cityNameAr"] = this.cityNameAr;
        data["cityNameEn"] = this.cityNameEn;
        data["useIsolatedDatabase"] = this.useIsolatedDatabase;
        data["hasCustomConnectionString"] = this.hasCustomConnectionString;
        data["logoUrl"] = this.logoUrl;
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface ISchoolMetadataDTO {
    id?: string;
    nameFr?: string;
    nameAr?: string;
    nameEn?: string;
    code?: string;
    addressFr?: string;
    addressAr?: string;
    addressEn?: string;
    regionId?: string;
    regionNameFr?: string;
    regionNameAr?: string;
    regionNameEn?: string;
    cityId?: string;
    cityNameFr?: string;
    cityNameAr?: string;
    cityNameEn?: string;
    useIsolatedDatabase?: boolean;
    hasCustomConnectionString?: boolean;
    logoUrl?: string;
    timeZoneId?: string;
}

export class SchoolSupplyDTO implements ISchoolSupplyDTO {
    nameFr?: string;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    descriptionFr?: string | undefined;
    descriptionAr?: string | undefined;
    descriptionEn?: string | undefined;

    constructor(data?: ISchoolSupplyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameFr = _data["nameFr"];
            this.nameAr = _data["nameAr"];
            this.nameEn = _data["nameEn"];
            this.descriptionFr = _data["descriptionFr"];
            this.descriptionAr = _data["descriptionAr"];
            this.descriptionEn = _data["descriptionEn"];
        }
    }

    static fromJS(data: any): SchoolSupplyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SchoolSupplyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameFr"] = this.nameFr;
        data["nameAr"] = this.nameAr;
        data["nameEn"] = this.nameEn;
        data["descriptionFr"] = this.descriptionFr;
        data["descriptionAr"] = this.descriptionAr;
        data["descriptionEn"] = this.descriptionEn;
        return data;
    }
}

export interface ISchoolSupplyDTO {
    nameFr?: string;
    nameAr?: string | undefined;
    nameEn?: string | undefined;
    descriptionFr?: string | undefined;
    descriptionAr?: string | undefined;
    descriptionEn?: string | undefined;
}

export class PagedResultOfSchoolSupplyDTO extends PagedResultBase implements IPagedResultOfSchoolSupplyDTO {
    results?: SchoolSupplyDTO[];

    constructor(data?: IPagedResultOfSchoolSupplyDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SchoolSupplyDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfSchoolSupplyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfSchoolSupplyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfSchoolSupplyDTO extends IPagedResultBase {
    results?: SchoolSupplyDTO[];
}

export class BookDTO implements IBookDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    authorNameFr?: string;
    authorNameAr?: string | undefined;
    authorNameEn?: string | undefined;
    isbn?: string | undefined;
    subject?: string;

    constructor(data?: IBookDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleFr = _data["titleFr"];
            this.titleAr = _data["titleAr"];
            this.titleEn = _data["titleEn"];
            this.authorNameFr = _data["authorNameFr"];
            this.authorNameAr = _data["authorNameAr"];
            this.authorNameEn = _data["authorNameEn"];
            this.isbn = _data["isbn"];
            this.subject = _data["subject"];
        }
    }

    static fromJS(data: any): BookDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BookDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleFr"] = this.titleFr;
        data["titleAr"] = this.titleAr;
        data["titleEn"] = this.titleEn;
        data["authorNameFr"] = this.authorNameFr;
        data["authorNameAr"] = this.authorNameAr;
        data["authorNameEn"] = this.authorNameEn;
        data["isbn"] = this.isbn;
        data["subject"] = this.subject;
        return data;
    }
}

export interface IBookDTO {
    titleFr?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    authorNameFr?: string;
    authorNameAr?: string | undefined;
    authorNameEn?: string | undefined;
    isbn?: string | undefined;
    subject?: string;
}

export class ScheduleConstraintsDTO implements IScheduleConstraintsDTO {
    courseSections?: CourseSectionConstraints[];
    startDate?: Date;
    endDate?: Date;

    constructor(data?: IScheduleConstraintsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["courseSections"])) {
                this.courseSections = [] as any;
                for (let item of _data["courseSections"])
                    this.courseSections!.push(CourseSectionConstraints.fromJS(item));
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScheduleConstraintsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleConstraintsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.courseSections)) {
            data["courseSections"] = [];
            for (let item of this.courseSections)
                data["courseSections"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        return data;
    }
}

export interface IScheduleConstraintsDTO {
    courseSections?: CourseSectionConstraints[];
    startDate?: Date;
    endDate?: Date;
}

export class CourseSectionConstraints implements ICourseSectionConstraints {
    courseId?: string;
    gradeSectionId?: string;
    requiredCapacity?: number;
    preferredDays?: DayOfWeek[];
    preferredStartTime?: string;
    preferredEndTime?: string;

    constructor(data?: ICourseSectionConstraints) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.gradeSectionId = _data["gradeSectionId"];
            this.requiredCapacity = _data["requiredCapacity"];
            if (Array.isArray(_data["preferredDays"])) {
                this.preferredDays = [] as any;
                for (let item of _data["preferredDays"])
                    this.preferredDays!.push(item);
            }
            this.preferredStartTime = _data["preferredStartTime"];
            this.preferredEndTime = _data["preferredEndTime"];
        }
    }

    static fromJS(data: any): CourseSectionConstraints {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSectionConstraints();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["gradeSectionId"] = this.gradeSectionId;
        data["requiredCapacity"] = this.requiredCapacity;
        if (Array.isArray(this.preferredDays)) {
            data["preferredDays"] = [];
            for (let item of this.preferredDays)
                data["preferredDays"].push(item);
        }
        data["preferredStartTime"] = this.preferredStartTime;
        data["preferredEndTime"] = this.preferredEndTime;
        return data;
    }
}

export interface ICourseSectionConstraints {
    courseId?: string;
    gradeSectionId?: string;
    requiredCapacity?: number;
    preferredDays?: DayOfWeek[];
    preferredStartTime?: string;
    preferredEndTime?: string;
}

export class ScheduleConflictCheckDTO implements IScheduleConflictCheckDTO {
    classroomId?: string;
    teacherId?: string;
    dayOfWeek?: DayOfWeek;
    startTime?: string;
    endTime?: string;
    excludeScheduleId?: string | undefined;

    constructor(data?: IScheduleConflictCheckDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classroomId = _data["classroomId"];
            this.teacherId = _data["teacherId"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.excludeScheduleId = _data["excludeScheduleId"];
        }
    }

    static fromJS(data: any): ScheduleConflictCheckDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleConflictCheckDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classroomId"] = this.classroomId;
        data["teacherId"] = this.teacherId;
        data["dayOfWeek"] = this.dayOfWeek;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["excludeScheduleId"] = this.excludeScheduleId;
        return data;
    }
}

export interface IScheduleConflictCheckDTO {
    classroomId?: string;
    teacherId?: string;
    dayOfWeek?: DayOfWeek;
    startTime?: string;
    endTime?: string;
    excludeScheduleId?: string | undefined;
}

export class BranchDto implements IBranchDto {
    id?: string;
    schoolId?: string;
    branchNameFr?: string;
    branchNameAr?: string;
    branchNameEn?: string | undefined;
    addressFr?: string;
    addressAr?: string;
    phone?: string;
    principalNameFr?: string;
    principalNameAr?: string;
    cityId?: string;

    constructor(data?: IBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schoolId = _data["schoolId"];
            this.branchNameFr = _data["branchNameFr"];
            this.branchNameAr = _data["branchNameAr"];
            this.branchNameEn = _data["branchNameEn"];
            this.addressFr = _data["addressFr"];
            this.addressAr = _data["addressAr"];
            this.phone = _data["phone"];
            this.principalNameFr = _data["principalNameFr"];
            this.principalNameAr = _data["principalNameAr"];
            this.cityId = _data["cityId"];
        }
    }

    static fromJS(data: any): BranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["schoolId"] = this.schoolId;
        data["branchNameFr"] = this.branchNameFr;
        data["branchNameAr"] = this.branchNameAr;
        data["branchNameEn"] = this.branchNameEn;
        data["addressFr"] = this.addressFr;
        data["addressAr"] = this.addressAr;
        data["phone"] = this.phone;
        data["principalNameFr"] = this.principalNameFr;
        data["principalNameAr"] = this.principalNameAr;
        data["cityId"] = this.cityId;
        return data;
    }
}

export interface IBranchDto {
    id?: string;
    schoolId?: string;
    branchNameFr?: string;
    branchNameAr?: string;
    branchNameEn?: string | undefined;
    addressFr?: string;
    addressAr?: string;
    phone?: string;
    principalNameFr?: string;
    principalNameAr?: string;
    cityId?: string;
}

export class CreateUserRequestDto implements ICreateUserRequestDto {
    userId?: string | undefined;
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string;
    phone?: string;
    cin?: string | undefined;
    occupation?: string | undefined;
    addressFr?: string | undefined;
    addressAr?: string | undefined;
    password?: string;
    type?: UserType;

    constructor(data?: ICreateUserRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.branchId = _data["branchId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.cin = _data["cin"];
            this.occupation = _data["occupation"];
            this.addressFr = _data["addressFr"];
            this.addressAr = _data["addressAr"];
            this.password = _data["password"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateUserRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["branchId"] = this.branchId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["cin"] = this.cin;
        data["occupation"] = this.occupation;
        data["addressFr"] = this.addressFr;
        data["addressAr"] = this.addressAr;
        data["password"] = this.password;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateUserRequestDto {
    userId?: string | undefined;
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string;
    phone?: string;
    cin?: string | undefined;
    occupation?: string | undefined;
    addressFr?: string | undefined;
    addressAr?: string | undefined;
    password?: string;
    type?: UserType;
}

export enum UserType {
    Student = "Student",
    Parent = "Parent",
    Staff = "Staff",
    Instructure = "Instructure",
    SchoolAdmin = "SchoolAdmin",
}

export class CreateStaffDTO implements ICreateStaffDTO {
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    departmentFr?: string | undefined;
    departmentAr?: string | undefined;
    role?: StaffRole;
    jobTitleFr?: string | undefined;
    jobTitleAr?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;

    constructor(data?: ICreateStaffDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.departmentFr = _data["departmentFr"];
            this.departmentAr = _data["departmentAr"];
            this.role = _data["role"];
            this.jobTitleFr = _data["jobTitleFr"];
            this.jobTitleAr = _data["jobTitleAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): CreateStaffDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStaffDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["departmentFr"] = this.departmentFr;
        data["departmentAr"] = this.departmentAr;
        data["role"] = this.role;
        data["jobTitleFr"] = this.jobTitleFr;
        data["jobTitleAr"] = this.jobTitleAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface ICreateStaffDTO {
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    departmentFr?: string | undefined;
    departmentAr?: string | undefined;
    role?: StaffRole;
    jobTitleFr?: string | undefined;
    jobTitleAr?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export class BulkStaffDTO implements IBulkStaffDTO {
    records?: StaffDTO[];
    initiatedBy?: string;

    constructor(data?: IBulkStaffDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(StaffDTO.fromJS(item));
            }
            this.initiatedBy = _data["initiatedBy"];
        }
    }

    static fromJS(data: any): BulkStaffDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BulkStaffDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        data["initiatedBy"] = this.initiatedBy;
        return data;
    }
}

export interface IBulkStaffDTO {
    records?: StaffDTO[];
    initiatedBy?: string;
}

export class StaffDTO implements IStaffDTO {
    id?: string;
    userId?: string;
    branchId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    departmentFr?: string | undefined;
    departmentAr?: string | undefined;
    role?: StaffRole;
    jobTitleFr?: string | undefined;
    jobTitleAr?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IStaffDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.branchId = _data["branchId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.departmentFr = _data["departmentFr"];
            this.departmentAr = _data["departmentAr"];
            this.role = _data["role"];
            this.jobTitleFr = _data["jobTitleFr"];
            this.jobTitleAr = _data["jobTitleAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): StaffDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["branchId"] = this.branchId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["departmentFr"] = this.departmentFr;
        data["departmentAr"] = this.departmentAr;
        data["role"] = this.role;
        data["jobTitleFr"] = this.jobTitleFr;
        data["jobTitleAr"] = this.jobTitleAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IStaffDTO {
    id?: string;
    userId?: string;
    branchId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    departmentFr?: string | undefined;
    departmentAr?: string | undefined;
    role?: StaffRole;
    jobTitleFr?: string | undefined;
    jobTitleAr?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export class StaffRoleDTO implements IStaffRoleDTO {
    staffId?: string;
    role?: StaffRole;
    requestorId?: string;

    constructor(data?: IStaffRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.role = _data["role"];
            this.requestorId = _data["requestorId"];
        }
    }

    static fromJS(data: any): StaffRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StaffRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["role"] = this.role;
        data["requestorId"] = this.requestorId;
        return data;
    }
}

export interface IStaffRoleDTO {
    staffId?: string;
    role?: StaffRole;
    requestorId?: string;
}

export class PagedResultOfStaffDTO extends PagedResultBase implements IPagedResultOfStaffDTO {
    results?: StaffDTO[];

    constructor(data?: IPagedResultOfStaffDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(StaffDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfStaffDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfStaffDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfStaffDTO extends IPagedResultBase {
    results?: StaffDTO[];
}

export class CreateStudentUserDTO implements ICreateStudentUserDTO {
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string;
    phone?: string | undefined;
    addressFr?: string | undefined;
    addressAr?: string | undefined;
    password?: string;

    constructor(data?: ICreateStudentUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.addressFr = _data["addressFr"];
            this.addressAr = _data["addressAr"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateStudentUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStudentUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["addressFr"] = this.addressFr;
        data["addressAr"] = this.addressAr;
        data["password"] = this.password;
        return data;
    }
}

export interface ICreateStudentUserDTO {
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string;
    phone?: string | undefined;
    addressFr?: string | undefined;
    addressAr?: string | undefined;
    password?: string;
}

export class CreateStudentDTO implements ICreateStudentDTO {
    parentId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    dateOfBirth?: Date;
    gender?: GenderEnum;
    status?: string;
    emergencyContact?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;

    constructor(data?: ICreateStudentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.status = _data["status"];
            this.emergencyContact = _data["emergencyContact"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): CreateStudentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStudentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["status"] = this.status;
        data["emergencyContact"] = this.emergencyContact;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface ICreateStudentDTO {
    parentId?: string;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    dateOfBirth?: Date;
    gender?: GenderEnum;
    status?: string;
    emergencyContact?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export class StudentStatusTransitionDTO implements IStudentStatusTransitionDTO {
    newStatus?: string;
    reason?: string;

    constructor(data?: IStudentStatusTransitionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newStatus = _data["newStatus"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): StudentStatusTransitionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentStatusTransitionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newStatus"] = this.newStatus;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IStudentStatusTransitionDTO {
    newStatus?: string;
    reason?: string;
}

export class StudentDetailDTO implements IStudentDetailDTO {
    student?: StudentDTO;
    medicalInfo?: string;
    emergencyContact?: string;
    previousSchool?: string;
    additionalNotes?: string;

    constructor(data?: IStudentDetailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.student = _data["student"] ? StudentDTO.fromJS(_data["student"]) : <any>undefined;
            this.medicalInfo = _data["medicalInfo"];
            this.emergencyContact = _data["emergencyContact"];
            this.previousSchool = _data["previousSchool"];
            this.additionalNotes = _data["additionalNotes"];
        }
    }

    static fromJS(data: any): StudentDetailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDetailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["medicalInfo"] = this.medicalInfo;
        data["emergencyContact"] = this.emergencyContact;
        data["previousSchool"] = this.previousSchool;
        data["additionalNotes"] = this.additionalNotes;
        return data;
    }
}

export interface IStudentDetailDTO {
    student?: StudentDTO;
    medicalInfo?: string;
    emergencyContact?: string;
    previousSchool?: string;
    additionalNotes?: string;
}

export class PagedResultOfStudentParentDTO extends PagedResultBase implements IPagedResultOfStudentParentDTO {
    results?: StudentParentDTO[];

    constructor(data?: IPagedResultOfStudentParentDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(StudentParentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfStudentParentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfStudentParentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfStudentParentDTO extends IPagedResultBase {
    results?: StudentParentDTO[];
}

export class StudentParentDTO implements IStudentParentDTO {
    parentId?: string;
    fullName?: string;
    relationship?: StudentParentRelationshipEnum;

    constructor(data?: IStudentParentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.fullName = _data["fullName"];
            this.relationship = _data["relationship"];
        }
    }

    static fromJS(data: any): StudentParentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentParentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["fullName"] = this.fullName;
        data["relationship"] = this.relationship;
        return data;
    }
}

export interface IStudentParentDTO {
    parentId?: string;
    fullName?: string;
    relationship?: StudentParentRelationshipEnum;
}

export enum StudentParentRelationshipEnum {
    Mother = "Mother",
    Father = "Father",
    Guardian = "Guardian",
}

export class PagedResultOfStudentDTO extends PagedResultBase implements IPagedResultOfStudentDTO {
    results?: StudentDTO[];

    constructor(data?: IPagedResultOfStudentDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(StudentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfStudentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfStudentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfStudentDTO extends IPagedResultBase {
    results?: StudentDTO[];
}

export class CreateTeacherDTO implements ICreateTeacherDTO {
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string | undefined;
    phone?: string | undefined;
    hireDate?: Date;
    specializationFr?: string | undefined;
    specializationAr?: string | undefined;
    status?: TeacherStatusEnum;

    constructor(data?: ICreateTeacherDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.specializationFr = _data["specializationFr"];
            this.specializationAr = _data["specializationAr"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateTeacherDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeacherDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["specializationFr"] = this.specializationFr;
        data["specializationAr"] = this.specializationAr;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateTeacherDTO {
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string | undefined;
    phone?: string | undefined;
    hireDate?: Date;
    specializationFr?: string | undefined;
    specializationAr?: string | undefined;
    status?: TeacherStatusEnum;
}

export class TeacherDTO implements ITeacherDTO {
    userId?: string;
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string | undefined;
    phone?: string | undefined;
    hireDate?: Date;
    specializationFr?: string | undefined;
    specializationAr?: string | undefined;
    status?: TeacherStatusEnum;

    constructor(data?: ITeacherDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.branchId = _data["branchId"];
            this.firstNameFr = _data["firstNameFr"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameFr = _data["lastNameFr"];
            this.lastNameAr = _data["lastNameAr"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.hireDate = _data["hireDate"] ? new Date(_data["hireDate"].toString()) : <any>undefined;
            this.specializationFr = _data["specializationFr"];
            this.specializationAr = _data["specializationAr"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TeacherDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeacherDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["branchId"] = this.branchId;
        data["firstNameFr"] = this.firstNameFr;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameFr"] = this.lastNameFr;
        data["lastNameAr"] = this.lastNameAr;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["hireDate"] = this.hireDate ? this.hireDate.toISOString() : <any>undefined;
        data["specializationFr"] = this.specializationFr;
        data["specializationAr"] = this.specializationAr;
        data["status"] = this.status;
        return data;
    }
}

export interface ITeacherDTO {
    userId?: string;
    branchId?: string | undefined;
    firstNameFr?: string;
    firstNameAr?: string;
    lastNameFr?: string;
    lastNameAr?: string;
    email?: string | undefined;
    phone?: string | undefined;
    hireDate?: Date;
    specializationFr?: string | undefined;
    specializationAr?: string | undefined;
    status?: TeacherStatusEnum;
}

export class PagedResultOfTeacherDTO extends PagedResultBase implements IPagedResultOfTeacherDTO {
    results?: TeacherDTO[];

    constructor(data?: IPagedResultOfTeacherDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TeacherDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfTeacherDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfTeacherDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfTeacherDTO extends IPagedResultBase {
    results?: TeacherDTO[];
}

export class TransferStatusUpdateDTO implements ITransferStatusUpdateDTO {
    newStatus?: TransferRequestStatus;
    adminComment?: string;
    reason?: string;
    changedBy?: string;
    changeReason?: TransferRequestChangeReasonEnum;

    constructor(data?: ITransferStatusUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newStatus = _data["newStatus"];
            this.adminComment = _data["adminComment"];
            this.reason = _data["reason"];
            this.changedBy = _data["changedBy"];
            this.changeReason = _data["changeReason"];
        }
    }

    static fromJS(data: any): TransferStatusUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferStatusUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newStatus"] = this.newStatus;
        data["adminComment"] = this.adminComment;
        data["reason"] = this.reason;
        data["changedBy"] = this.changedBy;
        data["changeReason"] = this.changeReason;
        return data;
    }
}

export interface ITransferStatusUpdateDTO {
    newStatus?: TransferRequestStatus;
    adminComment?: string;
    reason?: string;
    changedBy?: string;
    changeReason?: TransferRequestChangeReasonEnum;
}

export class TransferRequestUpdateDTO implements ITransferRequestUpdateDTO {
    toBranchId?: string | undefined;
    toSchoolId?: string | undefined;
    reason?: string;
    documents?: DocumentDTO[];
    updatedBy?: string;

    constructor(data?: ITransferRequestUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.toBranchId = _data["toBranchId"];
            this.toSchoolId = _data["toSchoolId"];
            this.reason = _data["reason"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentDTO.fromJS(item));
            }
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): TransferRequestUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransferRequestUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toBranchId"] = this.toBranchId;
        data["toSchoolId"] = this.toSchoolId;
        data["reason"] = this.reason;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["updatedBy"] = this.updatedBy;
        return data;
    }
}

export interface ITransferRequestUpdateDTO {
    toBranchId?: string | undefined;
    toSchoolId?: string | undefined;
    reason?: string;
    documents?: DocumentDTO[];
    updatedBy?: string;
}

export class PagedResultOfTransferRequestDTO extends PagedResultBase implements IPagedResultOfTransferRequestDTO {
    results?: TransferRequestDTO[];

    constructor(data?: IPagedResultOfTransferRequestDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TransferRequestDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfTransferRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfTransferRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultOfTransferRequestDTO extends IPagedResultBase {
    results?: TransferRequestDTO[];
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class AppException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isAppException = true;

    static isAppException(obj: any): obj is AppException {
        return obj.isAppException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new AppException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}